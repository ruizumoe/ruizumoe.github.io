[{"content":"自定义 archetypes 你还可以根据需要创建自定义 archetypes。例如，如果你有一个特定的类型的页面需要定制的元数据和默认内容，可以在 archetypes 文件夹中创建一个新的文件，并在其中定义所需的内容和元数据。\n要使用自定义 archetypes，你可以在 new 命令中指定自定义 archetypes 的名称。例如，如果你有一个名为 event.md 的自定义 archetypes，你可以使用以下命令创建一个新的事件页面：\n1 2 csharpCopy code $ hugo new event/my-new-event.md --kind event 在上面的示例中，--kind 标志指定了新内容的类型为 event，这将告诉 Hugo 使用 archetypes/event.md 文件作为模板。\n","date":"2023-03-05T19:17:50+08:00","image":"https://ruizumoe.github.io/img/background/helena-hertz-wWZzXlDpMog-unsplash.jpg","permalink":"https://ruizumoe.github.io/p/hogo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"hogo的使用技巧"},{"content":"创作主菜单及存档 制作主菜单UI 为了实现主菜单的叠层效果，创建3个Panel。在Unity中Panel的渲染规则时优先渲染位置靠下的Panel，因此后续用代码控制Panel的位置即可。\n控制代码\n最主要的代码就是transform的SetAsLastSibling方法，该方法能让当前GO在Hierarchy窗口中处于当前父GO的最下方\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class MenuUI : MonoBehaviour { public GameObject[] panels; /// \u0026lt;summary\u0026gt; /// 根据index调换panel位置，以显示在上层 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void SwitchPanel(int index) { for (int i = 0; i \u0026lt; panels.Length; i++) { if (i == index) { panels[i].transform.SetAsLastSibling(); } } } public void ExitGame() { Application.Quit(); Debug.Log(\u0026#34;GameQuit\u0026#34;); } } 为每个button设置点击事件，而即可\n存档UI\n每个存档UI显示游戏进行时间以及所在场景，因此需要代码来获取UI内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class SaveSlotUI : MonoBehaviour { public Text dataTime, dataScene; private Button _currentBtn; private int Index =\u0026gt; transform.GetSiblingIndex(); private void Awake() { _currentBtn = GetComponent\u0026lt;Button\u0026gt;(); _currentBtn.onClick.AddListener(LoadGameData); } private void LoadGameData() { Debug.Log(Index); } } 使用GetSiblingIndex来获得当前按钮的位置，同步存档的位置。\n创建游戏数据存储数据结构 Unity自带的Json保存方法并不能字典和列表数据，因此需要使用新的工具\ncom.unity.nuget.newtonsoft-json将该名称在package Manager中通过URL连接添加即可\n最主要的就是JsonConvert.SerializeObject和相应的反序列化方法\n在具体的代码中需要一个专门用于存放游戏内容的脚本GameSaveData，其是描述用于存储的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace WFarm.Save { [System.Serializable] public class GameSaveData { public string dataSceneName; public Dictionary\u0026lt;string, SerializableVector3\u0026gt; characterPosDict; /* 每个人物的位置 */ public Dictionary\u0026lt;string, List\u0026lt;SceneItem\u0026gt;\u0026gt; sceneItemDict; /*每个场景的物品*/ public Dictionary\u0026lt;string, List\u0026lt;SceneFurniture\u0026gt;\u0026gt; sceneFurnitureDict; /* 每个场景被制造出来的物品 */ public Dictionary\u0026lt;string, TileDetails\u0026gt; tileDetailsDict; public Dictionary\u0026lt;string, bool\u0026gt; firstLoadDict; public Dictionary\u0026lt;string, List\u0026lt;InventoryItem\u0026gt;\u0026gt; inventoryDict; /* 场景和人物存放的数据 */ public Dictionary\u0026lt;string, int\u0026gt; timeDict; /* 当前游戏时间 */ public int playerMoney; // NPC内容 public string targetScene; public bool npcInteractable; public int animationInstanceID; } } 然后需要一个专门用于保存的接口ISavable，以及控制存取的代码SaveLoadManager\nISavable需要让对应的类实现三个方法，即能够保存数据，读取数据，以及将自己注册进一个管理GO中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface ISavable { string GUID { get; } // c#新特性：接口可以预先编写功能 void RegisterSavable() { /* 如果某一个类实现了当前接口，那么其一定会将自己注册进入SaveLoadManager的存档列表中 */ SaveLoadManager.Instance.RegisterSavable(this); } GameSaveData GenerateSaveData(); void RestoreData(GameSaveData data); } 而SaveLoadManager.cs则需要控制所有需要被保存的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 namespace WFarm.Save { public class SaveLoadManager : Singleton\u0026lt;SaveLoadManager\u0026gt; { private List\u0026lt;ISavable\u0026gt; _savableList = new List\u0026lt;ISavable\u0026gt;(); public void RegisterSavable(ISavable savable) { if (!_savableList.Contains(savable)) _savableList.Add(savable); } } } 为了保存数据的唯一性，需要一个代码DataGUID，这个代码是一致运行的，创建一个GUID，如果当前内容的GUID不存在，则在awake()中生成一个独立的GUID，从而保证自己的唯一性。而每个单独的GameSaveData会有自己独立的GUID\n每个需要被保存的数据应该都含有该脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 [ExecuteAlways] public class DataGUID : MonoBehaviour { public string guid; private void Awake() { if (guid == String.Empty) { guid = System.Guid.NewGuid().ToString(); } } } 对player.cs进行存储数据\n在Player.cs脚本中实现ISavable接口，并装有GUID代码，在start方法中将当前当前方法注册进入SaveLoadManager中，注意为了能够调用该方法，我们需要在start方法中将类的ISavable单独定义出来。\n1 2 3 4 5 private void Start() { ISavable iSavable = this; iSavable.RegisterSavable(); // 将当前类注册进入SaveLoadManager } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #region 保存数据 public string GUID =\u0026gt; GetComponent\u0026lt;DataGUID\u0026gt;().guid; public GameSaveData GenerateSaveData() { GameSaveData saveData = new GameSaveData(); /* 存储坐标 */ saveData.characterPosDict = new Dictionary\u0026lt;string, SerializableVector3\u0026gt;(); saveData.characterPosDict.Add(this.GUID, new SerializableVector3(transform.position)); return saveData; } public void RestoreData(GameSaveData saveData) { transform.position = saveData.characterPosDict[this.GUID].ToVector3(); } #endregion 保存背包数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // inventoryManager.cs #region 保存数据 public string GUID =\u0026gt; GetComponent\u0026lt;DataGUID\u0026gt;().guid; public GameSaveData GenerateSaveData() { GameSaveData saveData = new GameSaveData(); saveData.playerMoney = playerCash; saveData.inventoryDict = new Dictionary\u0026lt;string, List\u0026lt;InventoryItem\u0026gt;\u0026gt;(); saveData.inventoryDict.Add(playerBag.name, playerBag.inventoryItemList); foreach (var boxData in _boxDataDict) { saveData.inventoryDict.Add(boxData.Key, boxData.Value); } return saveData; } public void RestoreData(GameSaveData data) { this.playerCash = saveData.playerMoney; this.playerBag = Instantiate(playerBagTemp); playerBag.inventoryItemList = saveData.inventoryDict[playerBag.name]; foreach (var boxData in data.inventoryDict) { if (boxData.Key == playerBag.name) continue; if (_boxDataDict.ContainsKey(boxData.Key)) { _boxDataDict[boxData.Key] = boxData.Value; } } EventHandler.CallUpdateInventoryUI(InventoryLocation.Player, playerBag.inventoryItemList); } #endregion 保存场景item数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // itemManager.cs #region 保存数据 public string GUID =\u0026gt; GetComponent\u0026lt;DataGUID\u0026gt;() ? GetComponent\u0026lt;DataGUID\u0026gt;().guid : String.Empty; public GameSaveData GenerateSaveData() { GameSaveData saveData = new GameSaveData(); // 默认情况只有加载和卸载场景的时候才获得场景的item和家具，因此此时需要去获取 GetAllSceneFurniture(); GetAllSceneItem(); saveData.sceneItemDict = this._sceneItemDict; saveData.sceneFurnitureDict = this._sceneFurnitureDict; return saveData; } public void RestoreData(GameSaveData data) { this._sceneItemDict = data.sceneItemDict; this._sceneFurnitureDict = data.sceneFurnitureDict; ReBuildSceneItems(); ReBuildSceneFurniture(); } #endregion 保存时间\n注意由于时间需要进行更新，因此每次加载游戏就需要重新加载场景，而时间也在这时候更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // TimeManager.cs #region 保存数据 public string GUID =\u0026gt; GetComponent\u0026lt;DataGUID\u0026gt;() ? GetComponent\u0026lt;DataGUID\u0026gt;().guid : String.Empty; public GameSaveData GenerateSaveData() { GameSaveData data = new GameSaveData(); data.timeDict = new Dictionary\u0026lt;string, int\u0026gt;(); data.timeDict.Add(\u0026#34;gameYear\u0026#34;, _gameYears); data.timeDict.Add(\u0026#34;gameSeason\u0026#34;, (int)_currentSeason); data.timeDict.Add(\u0026#34;gameMonth\u0026#34;, _gameMonth); data.timeDict.Add(\u0026#34;gameDays\u0026#34;, _gameDays); data.timeDict.Add(\u0026#34;gameHours\u0026#34;, _gameHours); data.timeDict.Add(\u0026#34;gameMinutes\u0026#34;, _gameMinutes); data.timeDict.Add(\u0026#34;gameSeconds\u0026#34;, _gameSeconds); return data; } public void RestoreData(GameSaveData data) { this._gameYears = data.timeDict[\u0026#34;gameYear\u0026#34;]; this._currentSeason = (Season)data.timeDict[\u0026#34;gameSeason\u0026#34;]; this._gameMonth = data.timeDict[\u0026#34;gameMonth\u0026#34;]; this._gameDays = data.timeDict[\u0026#34;gameDays\u0026#34;]; this._gameHours = data.timeDict[\u0026#34;gameHours\u0026#34;]; this._gameMinutes = data.timeDict[\u0026#34;gameMinutes\u0026#34;]; this._gameSeconds = data.timeDict[\u0026#34;gameSeconds\u0026#34;]; } #endregion 并且在加载场景后更新时间内容\n1 2 3 4 5 6 7 8 private void OnAfterSceneLoadEvent() { _gameClockPause = false; EventHandler.CallGameMinuteEvent(_gameMinutes, _gameHours, _gameDays, _currentSeason); EventHandler.CallGameDateEvent(_gameHours, _gameDays, _gameMonth, _gameYears, _currentSeason); EventHandler.CallLightShiftChangeEvent(_currentSeason, GetCurrentLightShift(), _timeDifference); } 地图数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // gridManager.cs #region 保存数据 public string GUID =\u0026gt; GetComponent\u0026lt;DataGUID\u0026gt;() ? GetComponent\u0026lt;DataGUID\u0026gt;().guid : String.Empty; public GameSaveData GenerateSaveData() { GameSaveData saveData = new GameSaveData(); saveData.tileDetailsDict = _tileDetailsMap; saveData.firstLoadDict = _firstLoadDic; return saveData; } public void RestoreData(GameSaveData saveData) { this._firstLoadDic = saveData.firstLoadDict; this._tileDetailsMap = saveData.tileDetailsDict; } #endregion 实现数据存储与加载 保存NPC的数据 在游戏保存时，NPC可能正处于移动状态，因此我们需要需要保存其可能要前往的位置，即NpcMovement\n人物数据保存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // NpcMovement.cs #region 保存数据 public string GUID =\u0026gt; GetComponent\u0026lt;DataGUID\u0026gt;() ? GetComponent\u0026lt;DataGUID\u0026gt;().guid : String.Empty; public GameSaveData GenerateSaveData() { /* 保存人物坐标点，目标坐标点等 */ GameSaveData saveData = new GameSaveData(); saveData.characterPosDict = new Dictionary\u0026lt;string, SerializableVector3\u0026gt;(); saveData.characterPosDict.Add(\u0026#34;currentPosition\u0026#34;, new SerializableVector3(transform.position)); saveData.characterPosDict.Add(\u0026#34;targetGridPos\u0026#34;, new SerializableVector3(_targetScenePos)); // 保存场景 saveData.dataSceneName = currentScene; saveData.targetScene = _targetScene; // 停止的动画片段 if (_stopAnimationClip != null) saveData.animationInstanceID = _stopAnimationClip.GetInstanceID(); // 是否可互动 saveData.npcInteractable = interactable; return saveData; } public void RestoreData(GameSaveData saveData) { this.currentScene = saveData.dataSceneName; this._targetScene = saveData.targetScene; transform.position = saveData.characterPosDict[\u0026#34;currentPosition\u0026#34;].ToVector3(); _targetScenePos = (Vector3Int)saveData.characterPosDict[\u0026#34;targetGridPos\u0026#34;].ToVector2(); if (saveData.animationInstanceID != 0) { _stopAnimationClip = Resources.InstanceIDToObject(saveData.animationInstanceID) as AnimationClip; } interactable = saveData.npcInteractable; // 人物已经加载完成，因此不能继续加载 _isInitialised = true; } #endregion 实现存储逻辑 在上述逻辑中，我们将需要存储的信息以GameSaveData的方法返回给了SaveLoadManager，因此多个GameSaveData共同组成一个存档数据，而游戏可以有多个存档数据。\n为了将存档与具体的存档栏对应，需要创建一个专门的数据结构DataSlot其将保存整个存档中所有的数据\n1 2 3 4 5 6 7 8 9 10 11 namespace WFarm.Save { [System.Serializable] public class DataSlot { /** 该类用于将存档与数据链接 */ /* 将guid和saveData对应，从而做到唯一性 */ public Dictionary\u0026lt;string, GameSaveData\u0026gt; dataDict = new Dictionary\u0026lt;string, GameSaveData\u0026gt;(); } } 每一个DataSlot对应了一个存档，每一个存档内部有一系列GameSaveData\n对数据进行写入和读出 将得到的数据写入存档\n调用该方法之前，需要会将所有需要存储数据的start中都挂载以下代码\n1 2 ISavable savable = this; savable.RegisterSavable(); 保证_savableList能够找到对应数据，然后将数据写入存档栏中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // SaveLoadManager.cs /// \u0026lt;summary\u0026gt; /// 将当前的数据，存放进入存档栏中 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;存档栏的序号\u0026lt;/param\u0026gt; public void Save(int index) { DataSlot dataSlot = new DataSlot(); foreach (var item in _savableList) { // 将guid和每个manager生成的gameSaveData进行组合 dataSlot.dataDict.Add(item.GUID, item.GenerateSaveData()); } dataSlots[index] = dataSlot; var resultPath = _jsonFolder + \u0026#34;SaveData\u0026#34; + index + \u0026#34;.json\u0026#34;; // 将数据存为json格式，然后序列化排版 var jsonData = JsonConvert.SerializeObject(dataSlot, Formatting.Indented); if (!File.Exists(_jsonFolder)) { Directory.CreateDirectory(_jsonFolder); } File.WriteAllText(resultPath, jsonData); } 接着将这些存档写入电脑\n1 2 3 4 5 protected override void Awake() { base.Awake(); _jsonFolder = Application.persistentDataPath + \u0026#34;/SAVE DATA/\u0026#34;; } Application.persistentDataPath 在windows下，存放位置是C盘的Appdata内部\n读出存档内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public void Load(int index) { // 获得存档地址 _currentDataIndex = index; var resultPath = _jsonFolder + \u0026#34;SaveData\u0026#34; + index + \u0026#34;.json\u0026#34;; if (!File.Exists(_jsonFolder)) { Directory.CreateDirectory(_jsonFolder); } // 转化数据 var stringData = File.ReadAllText(resultPath); DataSlot jsonData = JsonConvert.DeserializeObject\u0026lt;DataSlot\u0026gt;(stringData); // 读取数据内容 foreach (var savable in _savableList) { savable.RestoreData(jsonData.dataDict[savable.GUID]); } } 将读取存档和UI联系起来，并实现场景切换 保存当前的游戏场景\n注意在游戏打包以后，一开始只能显示一个场景，其他场景都是被加载出来的。因此UI场景应该是第一个被加载出来的，需要在awake中直接加载。\n1 2 3 4 5 6 private void Awake() { /* 开始游戏时启动UI场景 */ /* 由于UI应该优先出现，因此不使用异步加载，并且需要以叠加的方式呈现 */ SceneManager.LoadScene(\u0026#34;UI\u0026#34;, LoadSceneMode.Additive); } 制作读取游戏时，切换场景的代码\n此处代码有渐入渐出效果，且如果是在游玩游戏的过程中加载游戏，那么需要卸载当前处于的游戏场景，且需要保证不是PersistentScene\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // TransitionManager.cs public void RestoreData(GameSaveData saveData) { // 加载场景 // 不能直接使用Transition 因为Transition方法卸载当前场景，而加载存档的场景是persistentScene StartCoroutine(LoadSaveScene(saveData.dataSceneName)); } /// \u0026lt;summary\u0026gt; /// 加载存档游戏场景 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sceneName\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private IEnumerator LoadSaveScene(string sceneName) { yield return SceneFader(1f); // 如果当前场景不是PersistentScene，则说明在运行游戏，需要卸载当前场景 if (SceneManager.GetActiveScene().name != \u0026#34;PersistentScene\u0026#34;) { EventHandler.CallBeforeSceneUnloadEvent(); yield return SceneManager.UnloadSceneAsync(SceneManager.GetActiveScene().buildIndex); } SceneManager.LoadSceneAsync(sceneName); EventHandler.CallAfterSceneLoadEvent(); yield return SceneFader(0); } 完成加载游戏的具体逻辑 将开始游戏UI和游戏连接起来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // SaveSlotUI.cs private void OnEnable() { // 当该面板重新启动的时候（回到此处），就重新更新数据 SetupSlotUI(); } #region 绑定本文 private void SetupSlotUI() { if (_dataSlot != null) { dataTime.text = _dataSlot.DataTime; dataScene.text = _dataSlot.DataScene; } else { dataTime.text = \u0026#34;这个时间还未开始\u0026#34;; dataScene.text = \u0026#34;梦还未开始\u0026#34;; } } #endregion 但是在游戏一开始SaveLoadManager并不能获得存档的相关信息，因此需要先获取所有在电脑中的存储的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // SaveLoadManager.cs #region 从电脑中读取所有游戏存储数据 public void ReadSaveData() { if (Directory.Exists(_jsonFolder)) { for (int i = 0; i \u0026lt; dataSlots.Count; i++) { var resultPath = _jsonFolder + \u0026#34;SaveData\u0026#34; + i + \u0026#34;.json\u0026#34;; if (File.Exists(resultPath)) { var stringData = File.ReadAllText(resultPath); DataSlot jsonData = JsonConvert.DeserializeObject\u0026lt;DataSlot\u0026gt;(stringData); dataSlots[i] = jsonData; } } } } #endregion 以上方法在SaveLoadManager.cs的Awake中调用即可\n在后在SaveSlotUI.cs通过点击加载游戏，如果当前游戏有数据，则直接读取，没有数据则触发一个事件，该事件将让所有管理器去处理新游戏开启的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // SaveSlotUI.cs private void LoadGameData() { if (_dataSlot != null) { SaveLoadManager.Instance.Load(Index); } else // 开启新的游戏 { EventHandler.CallStartNewGameEvent(Index); } } 然后将所有需要处理新游戏的开启的代码进行处理\nplayer.cs\n保证play在主界面的时候不能乱跑\n1 2 3 4 5 private void OnStartNewGameEvent(int obj) { _inputDisable = false; transform.position = Settings.originPos; /* 设置初始场景 */ } InventoryManager.cs\n使用一个背包模板，在新游戏的时候，让角色得到背包数据\n1 2 3 4 5 6 7 8 9 10 11 12 /// \u0026lt;summary\u0026gt; /// 开始新游戏 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void OnStartNewGameEvent(int obj) { playerBag = Instantiate(playerBag); playerCash = Settings.PlayerStartMoney; /* 清空储物箱等数据 */ _boxDataDict.Clear(); EventHandler.CallUpdateInventoryUI(InventoryLocation.Player, playerBag.inventoryItemList); } TimeManager.cs\n加载游戏事件\n1 2 3 4 5 6 7 8 9 10 /// \u0026lt;summary\u0026gt; /// 开始新游戏 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void OnStartNewGameEvent(int obj) { /*初始化游戏事件*/ NewGameTime(); _gameClockPause = false; } ItemManager.cs\n1 2 3 4 5 6 7 8 9 10 /// \u0026lt;summary\u0026gt; /// 开始新游戏 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void OnStartNewGameEvent(int obj) { /*情况场景中原有的家具和item*/ _sceneItemDict.Clear(); _sceneFurnitureDict.Clear(); } TransitionManager.cs\n在设置早期，为了保证每次开始游戏执行顺序的正确性，将TransitionManager的start改为了协程的方式，以保证先加载场景，再执行加载场景后的事件函数。\n此时由于有新开始游戏事件，因此可以再该事件中呼叫加载场景后的事件\n1 2 3 4 private void OnStartNewGameEvent(int obj) { StartCoroutine(LoadSaveScene(startSceneName)); } 由于LoadSaveScene含有加载场景后事件，因此可以直接修改start内容，使其不再是IEumerator\n1 2 3 4 5 6 7 // 将IEnumerator进行了修改 private void Start() { ISavable savable = this; savable.RegisterSavable(); sceneFaderCanvasGroup = FindObjectOfType\u0026lt;CanvasGroup\u0026gt;(); } NPCManager.cs\n给所有NPC指定的位置和初始场景\n1 2 3 4 5 6 7 8 9 10 // npcManager.cs private void OnStartNewGameEvent(int obj) { foreach (var npcCharacter in npcPositions) { // NpcPosition中存放了npc的transform npcCharacter.npc.position = npcCharacter.startPos; npcCharacter.npc.GetComponent\u0026lt;NpcMovement\u0026gt;().StartScene = npcCharacter.startScene; } } LightManager.cs\n保证开始的灯光不为空\n1 2 3 4 private void OnStartNewGameEvent(int obj) { _currentLightShift = LightShift.Morning; } 将数据保存到对应的SaveSlot中 1 2 3 4 private void OnStartNewGameEvent(int index) { _currentDataIndex = index; } 解决加载后的BUG 解决背包问题 由于玩家的背包是通过模板生成的，因此其并没有初始化，当再次加载游戏的时候，此时背包为空，无法从存档中得到数据，因此每次加载的时候，都要重新生成一个背包，然后将背包的数据从存档中取得\n1 2 3 4 5 6 7 public void RestoreData(GameSaveData saveData) { this.playerCash = saveData.playerMoney; this.playerBag = Instantiate(playerBagTemp); playerBag.inventoryItemList = saveData.inventoryDict[playerBag.name]; // .... } 光照问题 1 private float _timeDifferent = Settings.LightChangeDuration; Npc移动目标丢失 NPC在移动的过程中保存场景的话，会导致加载存档后，NPC丢失了原本的行程，导致不会再执行行程内容，因此需要在加载场景后，让NPC根据已有信息再次执行行程。\n因此只要不是第一次加载游戏，那么就让NPC恢复数据的时候，重新加载行程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // NpcMovement.cs private void OnAfterSceneLoadEvent() { //.... /* 如果不是第一次加载人物，那么就重新生成路径 */ if (!_isFirstLoad) { _currentScenePos = _gird.WorldToCell(transform.position); // 直接生成一个新的行程，然后建立一个路径即可 var schedule = new ScheduleDetails(0, 0, 0, 0, _currentSeason, _targetScene, (Vector2Int)_nextGridPosition, _stopAnimationClip, interactable); BuildPath(schedule); _isFirstLoad = true; } } 在恢复数据的时候设置\n1 2 3 4 5 6 7 8 // NpcMovement.cs public void RestoreData(GameSaveData saveData) { // .. _isFirstLoad = false; // .. } 同时在每次新创建游戏的时候需要将其设置为true\n1 2 3 4 5 6 // NpcMovement.cs private void OnStartNewGameEvent(int obj) { _isInitialised = false; _isFirstLoad = true; } 暂停菜单和音量控制 制作一个在游戏中暂停的菜单 制作了菜单以后为了便于控制UI逻辑，将UIManager代码挂载到MainCanvas上，并设置其点击功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 public class UIManager : MonoBehaviour { [CanBeNull] private GameObject _menuCanvas; public GameObject menuPrefab; public Button settingBtn; public GameObject pausePanel; public Slider volumeSlider; private void Awake() { settingBtn.onClick.AddListener(TogglePausePanel); } private void OnEnable() { EventHandler.AfterSceneLoadEvent += OnAfterSceneLoadEvent; } private void OnDisable() { EventHandler.AfterSceneLoadEvent -= OnAfterSceneLoadEvent; } private void Start() { _menuCanvas = GameObject.FindWithTag(\u0026#34;MenuCanvas\u0026#34;); Instantiate(menuPrefab, _menuCanvas.transform); } #region 注册事件 /// \u0026lt;summary\u0026gt; /// 加载场景后关闭主菜单 /// \u0026lt;/summary\u0026gt; private void OnAfterSceneLoadEvent() { // 有子物体，则需要删去对应的prefab if (_menuCanvas.transform.childCount \u0026gt; 0) { Destroy(_menuCanvas.transform.GetChild(0).gameObject); } } #endregion /// \u0026lt;summary\u0026gt; /// 呼出暂停面板 /// \u0026lt;/summary\u0026gt; private void TogglePausePanel() { bool isOpen = pausePanel.activeInHierarchy; if (isOpen) { pausePanel.SetActive(false); Time.timeScale = 1; } else { System.GC.Collect(); pausePanel.SetActive(true); Time.timeScale = 0; } } /// \u0026lt;summary\u0026gt; /// btn的点击事件注册内容 /// \u0026lt;/summary\u0026gt; public void ReturnMenuCanvas() { Time.timeScale = 1; StartCoroutine(BackToMenu()); } /// \u0026lt;summary\u0026gt; /// 逐步返回 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private IEnumerator BackToMenu() { pausePanel.SetActive(false); yield return new WaitForSeconds(1f); Instantiate(menuPrefab, _menuCanvas.transform); } } 由于UI是通过Button控制，因此许多代码可以直接为btn添加点击事件而执行。\n为了保证在主菜单中的时候玩家不能操作，只能在加载场景以后才能移动\n在Player.cs的awake中添加\n1 _inputDisable = true; 添加音量控制 由于在设置AudioMixer的时候有将相关的变量暴露出来，因此可以通过对暴露出的变量进行控制的音量\n在AudioManager.cs中这是主音量的交方法\n1 2 3 4 5 6 7 8 9 //AudioManager.cs /// \u0026lt;summary\u0026gt; /// 设置主音量 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void SetMasterVolume(float value) { gameAudioMixer.SetFloat(\u0026#34;MasterVolume\u0026#34;, ConvertSoundVolume(value)); } 然后在UIManager中设置滑动条的监听\n1 2 3 4 5 6 // UIManager.cs private void Awake() { settingBtn.onClick.AddListener(TogglePausePanel); volumeSlider.onValueChanged.AddListener(AudioManager.Instance.SetMasterVolume); } 结束游戏 设置一个结束游戏的事件，在返回主菜单以后调用\n需要给player设置在结束游戏时不能移动\n在NPCMovement中设置当游戏结束时关闭正在移动的协程\n1 2 3 4 5 6 7 8 9 10 11 // NPCMovement /// \u0026lt;summary\u0026gt; /// 结束游戏 /// \u0026lt;/summary\u0026gt; private void OnEndGameEvent() { _loadedScene = false; _npcMove = false; if (_npcMovementRoutine != null) StopCoroutine(_npcMovementRoutine); } 在TimeManager中设置当游戏结束时停止计时。\n1 2 3 4 5 6 7 8 // TimeManager.cs /// \u0026lt;summary\u0026gt; /// 游戏返回主菜单，停止时间 /// \u0026lt;/summary\u0026gt; private void OnEndGameEvent() { _gameClockPause = true; } 在AudioManager中设置停止游戏静音\n1 2 3 4 5 6 7 8 9 /// \u0026lt;summary\u0026gt; /// 返回主菜单后静音 /// \u0026lt;/summary\u0026gt; private void OnEndGameEvent() { if (_soundRoutine != null) StopCoroutine(_soundRoutine); muteSnapshot.TransitionTo(1f); } 在SaveLoadManager.cs中设置返回主菜单的时候保存游戏进度\n1 2 3 4 5 // SaveLoadManager.cs private void OnEndGameEvent() { Save(_currentDataIndex); } 在TransitionManager中关闭当前场景，并卸载，因为有渐进渐出效果，因此需要使用协程\n1 2 3 4 5 6 7 8 9 10 11 /// \u0026lt;summary\u0026gt; /// 返回主菜单的时候卸载所有场景 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private IEnumerator UnloadScene() { EventHandler.CallBeforeSceneUnloadEvent(); yield return SceneFader(1f); yield return SceneManager.UnloadSceneAsync(SceneManager.GetActiveScene().buildIndex); yield return SceneFader(0f); } 检测鼠标位置是否有已经建造的家具 思路在于获得当前鼠标的位置以及当前建造物品的碰撞体大小，然后去以鼠标点为起点，碰撞体大小为范围检测该范围内是否有碰撞体，如果有碰撞体，继续检测碰撞体是否有家具组件。\n1 2 3 4 5 6 7 8 9 10 // CursorManager.cs private bool HaveFurnitureInRadius(BluePrintDetails bluePrintDetails) { var buildItem = bluePrintDetails.buildPrefab; Vector2 point = _mouseWorldPos; var size = buildItem.GetComponent\u0026lt;BoxCollider2D\u0026gt;().size; var otherColl = Physics2D.OverlapBox(point, size, 0); return otherColl is not null \u0026amp;\u0026amp; otherColl.GetComponent\u0026lt;Furniture\u0026gt;(); } 注意：OverlapBox方法不仅能检测碰撞体，也能检测trigger，而每个场景都有一个巨大的边界trigger，因此需要将这些边界的图层设置为Ignore Raycast\n后记 注意动画是否有退出时间 不同脚本的各自的awake和start的执行顺序不能确定，但是一定都是先执行完所有的awake在执行start。 切换动画（设置为AniatorOverrideController），一个基本的AnimatorController可以通过上转来交由AniatorOverrideController控制，从而实现动画的替换。 构建路径的时候使用的是栈，所以在跨场景移动的时候，需要先写入从当前位置到目标位置。NPC跨场景移动的时候先将当前任意位置到当前场景的传送区域的位置压入栈，然后再写下一场景的传送区域到目标位置。 时间变化量是deltaTime（Time和FixTime） 自适应UI的三个组件 由于event事件是在OnEnable中声明的，因此这些时间触发的实际也是在OnEnable的生命周期中，即在Start和Update之前 不在同一个场景的内容可以通过标签查找 将代码的类型改写为IEnumerator，可以控制代码内部的执行顺序，比如先异步加载场景，然后执行场景加载后呼叫的事件；start是唯一一个可以将返回类型改写为IEnumerator的声明周期函数。 ","date":"2023-03-05T19:16:55+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%8D%81%E4%BA%94/","title":"麦田物语开发日记(十五)"},{"content":"昼夜交替系统（切换灯光） 升级URP 通过切换URP的全局光的效果来实现昼夜切换，然后通过定义一个专门的数据结构来记录光源在不同时刻的光照强度，根据不同的时刻来触发切换数据即可。\n升级URP 从Package Manager中寻找URP包，然后进行安装，安装完成后，直接在项目新建一个URP的渲染管线Rendering-\u0026gt;URP Asset(with 2d Render)/ 2DRender , 由于是2.5D游戏，因此需要将渲染模式修改为Custom Axis\n然后再项目设置里修改默认的渲染管线为当前管线\n然后将项目的素材升级到URPWindow-\u0026gt;Rendering-\u0026gt;Render Pipeline Convert，\n先勾选所有材质然后初始化Initialize Convert ，然后进行转化\n添加灯光 直接在Hierarchy中新建需要的光源Light-\u0026gt;Global Light，其中Target Sorting Layer可以选择该光源能够照亮的内容; Instensity光照强度\n升级了URP以后，粒子系统也需要进行更新，在粒子系统的Render中，将材质从Default-ParticleSystem修改为Sprite-lit-default（需要取消隐藏才能显示），这样粒子系统才能在全局光照下（夜间颜色才统一）；\n添加点光源的流程也是一样的。\n根据时间来切换灯光 通过一个SO文件来控制所有灯光的具体数值，然后每个灯光有一个管理的脚本LightController，用于切换所有灯光数值内容，然后一个管理整个场景的灯光的脚本LightManager，用于在切换场景后更新所有场景中的光源\n灯光具体数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [CreateAssetMenu(fileName = \u0026#34;LightPattenList_SO\u0026#34;, menuName = \u0026#34;Light/LightPatten\u0026#34;)] public class LightPattenList_SO : ScriptableObject { public List\u0026lt;LightDetails\u0026gt; lightDetailsList; /// \u0026lt;summary\u0026gt; /// 通过当前所处的季节和时间段，得到当前灯光的具体数据 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;season\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lightShift\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public LightDetails GetLightDetails(Season season, LightShift lightShift) { return lightDetailsList.Find(l =\u0026gt; season == l.season \u0026amp;\u0026amp; lightShift == l.lightShift); } } [System.Serializable] public class LightDetails { public Color lightColor; public float lightIntensity; public Season season; public LightShift lightShift; } 控制灯光组件\n灯光组件Light2D的组件所处于using UnityEngine.Rendering.Universal;组件中\n控制日出灯光 设定日出和日落对应的时间，在Settings.cs中，使用TimeSpan来设定一个时间戳记录日出和日落时间，然后在TimeManager中每度过一分钟，计算一次当前的灯光。同时为了避免灯光突然切换，设置一个灯光切换的持续时间。\n1 2 3 4 5 // Settings中 /* 昼夜系统相关内容 */ public static TimeSpan morningTime = new TimeSpan(5, 0, 0); public static TimeSpan nightTime = new TimeSpan(19, 0, 0); public const float LightChangeDuration = 15f; /* 灯光的切换时间（现实时间） */ 然后在TimeManager中设置昼夜切换的事件，根据游戏时间获得当前的切换状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private LightShift GetCurrentLightShift() { if ((GameTime \u0026gt;= Settings.morningTime \u0026amp;\u0026amp; GameTime \u0026lt;= Settings.nightTime)) { _timeDifference = (float)(GameTime - Settings.morningTime).TotalMinutes; return LightShift.Morning; } else { _timeDifference = Mathf.Abs((float)((GameTime - Settings.nightTime)).TotalMinutes); return LightShift.Night; } return LightShift.Morning; } 并且在游戏一开始，以及每一分钟都呼叫一次昼夜切换相关的事件\n1 EventHandler.CallLightShiftChangeEvent(_currentSeason, GetCurrentLightShift(), _timeDifference); 对于LightManager来说，只需要保证每次被呼叫昼夜切换事件和切换场景的时候，更新当前场景的所有内容即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private void OnLightShiftChangeEvent(Season currentSeason, LightShift currentLightShift, float timeDifference) { _currentSeason = currentSeason; _currentLightShift = currentLightShift; _timeDifferent = timeDifference; foreach (LightController lightController in _sceneLightControllers) { /* 依次调用所有灯光的切换算法 */ lightController.ChangeLightShift(_currentSeason, _currentLightShift, _timeDifferent); } } private void OnAfterSceneLoadEvent() { _sceneLightControllers = FindObjectsOfType\u0026lt;LightController\u0026gt;(); foreach (LightController lightController in _sceneLightControllers) { /* 依次调用所有灯光的切换算法 */ lightController.ChangeLightShift(_currentSeason, _currentLightShift, _timeDifferent); } } 在LightController.cs中具体执行灯光的切换方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 改变灯光的方法 */ public void ChangeLightShift(Season currentSeason, LightShift currentLightShift, float timeDifference) { _targetLightDetails = currentLightData.GetLightDetails(currentSeason, currentLightShift); /* 设定光照数值 */ float gameTimeDuration = Settings.LightChangeDuration * (Settings.GameTimeThreshold * 60); if (timeDifference \u0026lt; Settings.LightChangeDuration) { // 此时timeDifference是日出或日落时间与当前时间的差距分钟数 Color colorOffset = (_targetLightDetails.lightColor - _currentLight2D.color) / Settings.LightChangeDuration * timeDifference; /* 计算从日出日落标准时间和目前的差值 */ _currentLight2D.color += colorOffset; /* 获得当前时间差下对应的初始天色 */ /* 使用DOTween插件缓慢切换灯光 */ DOTween.To(() =\u0026gt; _currentLight2D.color, c =\u0026gt; _currentLight2D.color = c, _targetLightDetails.lightColor, gameTimeDuration - timeDifference); DOTween.To(() =\u0026gt; _currentLight2D.intensity, i =\u0026gt; _currentLight2D.intensity = i, _targetLightDetails.lightIntensity, gameTimeDuration - timeDifference); } else { _currentLight2D.color = _targetLightDetails.lightColor; _currentLight2D.intensity = _targetLightDetails.lightIntensity; } } 1 float gameTimeDuration = Settings.LightChangeDuration * (Settings.GameTimeThreshold * 60); 由于DOTween的切换速度是根据现实时间来设置的，而游戏时间流速更快，此处代码是为了将我们预计的游戏中昼夜切换时间转化为现实的具体时间\n","date":"2023-03-05T19:16:47+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%8D%81%E4%BA%8C/","title":"麦田物语开发日记(十二)"},{"content":"图纸建造功能 图纸的基本数据结构 在该模块中图纸系统，主要通过检测人物背包中的数据内容，然后完成建造功能，因此需要一个基本的So文件来创建构建建造功能的数据存储内容。\n然后是显示构造内容的panel，获取该面板中的元素信息，如果鼠标指针检测的物品是可显示内容，因此就显示该Panel，此时Panel的具体内容显示需要通过循环去获取.\n构造图纸的基本数据结构 该数据结构用于记录图纸的基本数据信息，以及需要使用的数据的内容。然后在InventoryManager中调用记录的数据结构即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [CreateAssetMenu(fileName = \u0026#34;BluePrintDataList_SO\u0026#34;, menuName = \u0026#34;Inventory/BluePrintData\u0026#34;)] public class BluePrintDataList_SO : MonoBehaviour { public List\u0026lt;BluePrintDetails\u0026gt; bluePrintDataList; public BluePrintDetails GetBluePrintDetails(int itemId) { return bluePrintDataList.Find(b =\u0026gt; b.ID == itemId); } } [System.Serializable] public class BluePrintDetails { public int ID; public InventoryItem[] items; public int[] itemAmounts; } 在浮窗中显示图纸所需要的资源信息 获取浮窗对应窗口的控制权，并通过循环的方式，去获得图纸所需要的资源信息和数量，然后以此赋值给浮窗对应的资源内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // ItemToolTips.cs /// \u0026lt;summary\u0026gt; /// 显示图纸所需要资源的浮窗 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;itemID\u0026#34;\u0026gt;图纸item的ID\u0026lt;/param\u0026gt; public void SetResourceTooltips(int itemID) { /* 获得图纸蓝图 */ resourcePanel.gameObject.SetActive(true); BluePrintDetails bluePrintDetails = InventoryManager.Instance.bluePrintDataList.GetBluePrintDetails(itemID); /* 循环的方式更新UI */ for (int i = 0; i \u0026lt; resourceImg.Length; i++) { if (i \u0026lt; bluePrintDetails.items.Length) { var needResource = bluePrintDetails.items[i]; var itemDetails = InventoryManager.Instance.GetItemDetails(needResource.itemID); if (itemDetails == null) continue; resourceImg[i].sprite = itemDetails.itemIcon; resourceImg[i].gameObject.SetActive(true); resourceImg[i].transform.GetChild(0).GetComponent\u0026lt;TextMeshProUGUI\u0026gt;().text = needResource.itemAmount.ToString(); } else { resourceImg[i].gameObject.SetActive(false); } } } 显示所需资源的具体UI 1 2 3 4 5 6 7 8 9 10 // showItemDetails.cs 中的 OnPointerEnter方法 /* 判断当前的物体是图纸 */ if (_slotUI.slotItemDetails.itemType == ItemType.Furniture) { InventoryUI.itemTooltip.SetResourceTooltips(_slotUI.slotItemDetails.itemID); } else { InventoryUI.itemTooltip.CloseResourceTooltips(); } 完善建造流程 建造的基本流程：\n鼠标能够显示当前物品能否正常建造，因此需要对鼠标的检查函数进行补充\n如果可以建造，直接获取图纸的内容，并生成对应的item\n对鼠标UI进行改造，增加当前物品是否能建造的图标 当选择内容是图纸的时候，则在鼠标位置显示对应图片 1 2 3 4 5 6 7 8 9 10 11 12 // CursorManager.cs 的OnItemSelectCursorImage方法 /* 显示建造物品内容 */ if (itemDetail.itemType == ItemType.Furniture) { _buildImg.gameObject.SetActive(true); _buildImg.sprite = itemDetail.itemIcon; _buildImg.SetNativeSize(); } else { _buildImg.gameObject.SetActive(false); } 设置图片跟随鼠标\n1 2 /* 设置图片跟随鼠标 */ _buildImg.rectTransform.position = Input.mousePosition; 同时需要注意当与UI互动的时候需要关闭图片\n保证鼠标点击的位置能够正确显示可以建造的图片 1 2 3 4 5 6 7 8 9 10 // cursorManager.cs 的CheckCursorValid()方法 case ItemType.Furniture: _buildImg.gameObject.SetActive(true); BluePrintDetails bluePrintDetails = InventoryManager.Instance.bluePrintDataList.GetBluePrintDetails(_currentItem.itemID); if (currentTile.canPlaceFurniture \u0026amp;\u0026amp; InventoryManager.Instance.CheckStock(bluePrintDetails.ID) \u0026amp;\u0026amp; !HaveFurnitureInRadius(bluePrintDetails)) SetCursorValid(); else SetCursorInvalid(); break; 检测库存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // InventoryManager.cs 显示 /// \u0026lt;summary\u0026gt; /// 检测背包中是否含有满足当前选中的物品 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentItemID\u0026#34;\u0026gt;获得图纸ID\u0026lt;/param\u0026gt; public bool CheckStock(int currentItemID) { BluePrintDetails bluePrintDetails = bluePrintDataList.GetBluePrintDetails(currentItemID); foreach (InventoryItem bluePrintItem in bluePrintDetails.items) { InventoryItem playerBagItem = playerBag.GetPlayerBagItemById(bluePrintItem.itemID); if (playerBagItem.itemAmount != 0) { if (playerBagItem.itemAmount \u0026lt; bluePrintItem.itemAmount) { return false; } } else { return false; } } return true; } 检测重叠 使用一个新的脚本Furniture.cs来控制被建造的物品，每个被建造的物品都需要有这个代码\n实现构造 在GridMapManager.cs中直接呼叫建筑事件，该事件需要ItemManager来控制物体生成，使用InventoryManager来扣除资源\n1 2 3 4 5 6 7 8 9 10 11 /// \u0026lt;summary\u0026gt; /// 根据当前蓝图的ID，生成对应的物品 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;bluePrintId\u0026#34;\u0026gt;蓝图ID\u0026lt;/param\u0026gt; private void OnBuildFurnitureEvent(int bluePrintId, Vector3 mousePos) { BluePrintDetails bluePrintDetails = InventoryManager.Instance.bluePrintDataList.GetBluePrintDetails(bluePrintId); var BuildItem = Instantiate(bluePrintDetails.buildPrefab, mousePos, Quaternion.identity, _itemParent.transform); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // InventoryManager.cs /// \u0026lt;summary\u0026gt; /// 蓝图建造后移除背包资源 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;bluePrintId\u0026#34;\u0026gt;蓝图ID\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mousePos\u0026#34;\u0026gt;鼠标的位置\u0026lt;/param\u0026gt; private void OnBuildFurnitureEvent(int bluePrintId, Vector3 mousePos) { BluePrintDetails bluePrintDetails = bluePrintDataList.GetBluePrintDetails(bluePrintId); /* 移除使用资源 */ foreach (var bluePrintItem in bluePrintDetails.items) { RemoveItem(bluePrintItem.itemID, bluePrintItem.itemAmount); } /* 移除图纸 */ RemoveItem(bluePrintId, 1); } 实现存储箱构造，以及相关构造物品的存储。 实现构造物品的存储，和实现场景item的存储方式类似，也是构造建筑物品的信息和对应的坐标，在场景切换前保存对应的构造物品的信息，场景加载时，获得图纸的相关信息并生成对应的物品即可。\n基础创建内容 1 2 3 4 5 6 7 8 9 10 11 // dataCollection.cs中存储的建造物品信息 /// \u0026lt;summary\u0026gt; /// 场景中由蓝图构造的物品信息 /// \u0026lt;/summary\u0026gt; [System.Serializable] public class SceneFurniture { // todo 更多信息 public int bluePrintID; public SerializableVector3 itemPos; } 保证创建的内容在转换场景时也能保存 在ItemManager.cs中注册场景切换时候的事件，保证每次移除场景的时候，将当前场景所有物品都存放进对应字典，而加载场景时，从字典中生成所有物品\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // ItemManager.cs /// \u0026lt;summary\u0026gt; /// 将场景中所有建造物品全部存储在字典中 /// \u0026lt;/summary\u0026gt; private void GetAllSceneFurniture() { List\u0026lt;SceneFurniture\u0026gt; currentFurnitureList = new List\u0026lt;SceneFurniture\u0026gt;(); /* 获得当前场景所有furniture信息 */ foreach (Furniture furniture in FindObjectsOfType\u0026lt;Furniture\u0026gt;()) { SceneFurniture newSceneFurniture = new SceneFurniture(); newSceneFurniture.bluePrintID = furniture.bluePrintId; newSceneFurniture.itemPos = new SerializableVector3(furniture.transform.position); currentFurnitureList.Add(newSceneFurniture); } /* 更新当前场景的furniture字典 */ if (_sceneFurnitureDict.ContainsKey(SceneManager.GetActiveScene().name)) { _sceneFurnitureDict[SceneManager.GetActiveScene().name] = currentFurnitureList; } else { _sceneFurnitureDict.Add(SceneManager.GetActiveScene().name, currentFurnitureList); } } /// \u0026lt;summary\u0026gt; /// 重新构建场景中的所有建造物品 /// \u0026lt;/summary\u0026gt; public void ReBuildSceneFurniture() { List\u0026lt;SceneFurniture\u0026gt; currentFurnitureList = new List\u0026lt;SceneFurniture\u0026gt;(); /*获取字典中当前场景item的存储*/ if (_sceneFurnitureDict.TryGetValue(SceneManager.GetActiveScene().name, out currentFurnitureList)) { if (currentFurnitureList != null) { // 重建所有内容 foreach (SceneFurniture item in currentFurnitureList) { OnBuildFurnitureEvent(item.bluePrintID, item.itemPos.ToVector3()); } } } } 构造存储箱需要一个专门控制背包脚本，该脚本需要控制背包的具体数据，以及可互动的相关控制，由于会产生多个存储箱，为了避免存储箱的数据一致，因此需要创建一个专门用于保存存储箱数据的SO模板，每个存储箱的数据都是从模板中复制得到的。\n制作储物箱的GO 对于储物箱来说，需要有两个碰撞体，一个保证玩家的碰撞，一个设置为触发器，当进入范围并点击对应按键，就可以打开储物箱。\n储物箱数据控制 使用InventoryBag_SO构建一个存储箱的数据存储模板BoxBagTemplate，每个储物箱默认数据是从该模板生成的。\n然后使用一个专门的代码来保存每个存储箱保有的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Box : MonoBehaviour { public InventoryBag_SO bagSOTemplate; /* 数据模板 */ private InventoryBag_SO _currentBagData; /* 当前箱子保有的数据 */ private bool _canOpen = false; private bool _isOpen; public GameObject openSign; private void OnEnable() { if (_currentBagData == null) { _currentBagData = Instantiate(bagSOTemplate); } } private void Update() { if (!_isOpen \u0026amp;\u0026amp; _canOpen \u0026amp;\u0026amp; Input.GetMouseButtonDown(1)) { /* 打开背包 */ EventHandler.CallBaseBagOpenEvent(SlotType.Box, _currentBagData); _isOpen = true; } if ((!_canOpen \u0026amp;\u0026amp; _isOpen) || (_isOpen \u0026amp;\u0026amp; Input.GetKeyDown(KeyCode.Escape))) { EventHandler.CallBaseBagCloseEvent(SlotType.Box, _currentBagData); _isOpen = false; } } #region 碰撞检测 private void OnTriggerEnter2D(Collider2D other) { if (other.CompareTag(\u0026#34;Player\u0026#34;) \u0026amp;\u0026amp; !_isOpen) { _canOpen = true; openSign.SetActive(true); } } private void OnTriggerExit2D(Collider2D other) { if (other.CompareTag(\u0026#34;Player\u0026#34;) \u0026amp;\u0026amp; !_isOpen) { _canOpen = false; openSign.SetActive(false); } } #endregion } 然后需要对应修改打开和关闭UI的代码InventoryUI.cs，为其打开背包的事件添加对应的背包格子Slot\n我们设置的每一个背包格子都是特殊的种类，因此要设置不同的预制体来控制生成的背包格子类型\n1 2 3 4 5 6 7 // 在inventory.cs中的 OnBaseBagOpenEvent GameObject slotPrefab = slotType switch { SlotType.Shop =\u0026gt; shopSlotPrefab, SlotType.Box =\u0026gt; boxSlotPrefab, _ =\u0026gt; null }; 由于每个储物箱内容的生成需要在储物箱一开始被创建的时候就被赋值，而创建过程是在ItemManager的OnEnable中被使用的，因此其只能在Box的初始化赋值也只能OnEnable中执行，否则通过事件去获得Box存储的数据则会出错。\n完成存储箱和玩家的背包的数据交换，以及切换场景的物品保存 由于需要实现存储箱和玩家背包的拖拽数据交换，因此需要在对应的SlotUI.CS中去处理拖拽完成方法OnEndDrag\n如果要玩家背包与储物箱数据进行交换，首先要知道是哪一个储物箱的数据，因此需要在InventoryManager中注册打开储物箱时候的事件，用于获得打开的储物箱的具体数据。\n1 2 3 4 5 6 7 8 9 10 11 12 /// \u0026lt;summary\u0026gt; /// 打开某一类型的背包的时候，绑定数据 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;slotType\u0026#34;\u0026gt;打开背包的种类\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;bagSO\u0026#34;\u0026gt;背包的具体数据\u0026lt;/param\u0026gt; private void OnBaseBagOpenEvent(SlotType slotType, InventoryBag_SO bagSO) { if (slotType == SlotType.Box) { _currentBoxBag = bagSO; } } 然后需要设定新的交换函数，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /// \u0026lt;summary\u0026gt; /// 交换背包数据 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;fromIndex\u0026#34;\u0026gt;交换来源的Index\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;locationFrom\u0026#34;\u0026gt;交换来源的类型\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;targetIndex\u0026#34;\u0026gt;交换目标的Index\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;locationTarget\u0026#34;\u0026gt;交换目标的类型\u0026lt;/param\u0026gt; public void SwapPlayerBagItem(int fromIndex, InventoryLocation locationFrom, int targetIndex, InventoryLocation locationTarget) { List\u0026lt;InventoryItem\u0026gt; fromItemList = GetItemList(locationFrom); List\u0026lt;InventoryItem\u0026gt; targetItemList = GetItemList(locationTarget); if (targetIndex \u0026gt;= GetItemList(locationTarget).Count) return; InventoryItem fromItem = fromItemList[fromIndex]; InventoryItem targetItem = targetItemList[targetIndex]; if (targetItem.itemAmount == 0) { targetItemList[targetIndex] = fromItem; fromItemList[fromIndex] = new InventoryItem(); } // 两个物品相同 else if (fromItem.itemID == targetItem.itemID) { targetItem.itemAmount += fromItem.itemAmount; targetItemList[targetIndex] = targetItem; fromItemList[fromIndex] = new InventoryItem(); } else // 两个不同的物品 { fromItemList[fromIndex] = targetItem; targetItemList[targetIndex] = fromItem; } EventHandler.CallUpdateInventoryUI(locationFrom, fromItemList); EventHandler.CallUpdateInventoryUI(locationTarget, targetItemList); } 1 2 3 4 5 6 // slotui.cs 中修改OnEndDrag else if (slotType != SlotType.Shop \u0026amp;\u0026amp; targetSlot.slotType != SlotType.Shop \u0026amp;\u0026amp; slotType != targetSlot.slotType) { InventoryManager.Instance.SwapPlayerBagItem(slotIndex, SlotLocation, targetSlot.slotIndex, targetSlot.SlotLocation); } 根据slot的类型来获得当前交换的类型\n1 2 3 4 5 6 7 8 9 10 11 12 public InventoryLocation SlotLocation { get { return slotType switch { SlotType.Bag =\u0026gt; InventoryLocation.Player, SlotType.Shop =\u0026gt; InventoryLocation.Shop, SlotType.Box =\u0026gt; InventoryLocation.Box }; } } 切换场景时，保存存储箱中的数据 方法类似于保存场景数据，由于我们是保存存储箱的数据，因此将该部分内容存储到InventoryManager中\n由于每个场景可能有多个箱子，因此每个场景中每个箱子存储的数据需要是独立的，因此每个key需要以场景加序号的方式进行设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 在InventoryManager.cs中保存箱子的具体数据，并设置查询方法 /* 保存存储箱的内容 */ private Dictionary\u0026lt;string, List\u0026lt;InventoryItem\u0026gt;\u0026gt; _boxDataDict = new Dictionary\u0026lt;string, List\u0026lt;InventoryItem\u0026gt;\u0026gt;(); public int BoxDataDictCount =\u0026gt; _boxDataDict.Count; /// \u0026lt;summary\u0026gt; /// 根据key，找出存储箱总控字典中存储的数据 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;key对应的存储箱数据\u0026lt;/returns\u0026gt; public List\u0026lt;InventoryItem\u0026gt; GetBoxDataListFromDick(string key) { if (_boxDataDict.ContainsKey(key)) return _boxDataDict[key]; else return null; } /// \u0026lt;summary\u0026gt; /// 将每个储物箱的数据添加进入字典中 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;boxData\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void AddDataToBoxDict(Box boxData) { string key = boxData.name + boxData.boxIndex; _boxDataDict.Add(key, boxData.GetBoxDataSO().inventoryItemList); } Key使用箱子的名称和其序号叠加的方式来设置，因此每当创建一个箱子的时候都需要为其设置序号，\n1 2 3 4 5 6 // itemManager.cs 的OnBuildFurnitureEvent方法中添加 if (BuildItem.GetComponent\u0026lt;Box\u0026gt;()) { BuildItem.GetComponent\u0026lt;Box\u0026gt;().boxIndex = InventoryManager.Instance.BoxDataDictCount; BuildItem.GetComponent\u0026lt;Box\u0026gt;().BoxDataInit(); } 当存在序号以后，为了保证每次重建箱子的时候，能得到对应箱子的数据，因此箱子每次重建都需要对其中的数据进行初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // box.cs中对箱子的数据进行初始化 public void BoxDataInit(int curIndex) { boxIndex = curIndex; string key = this.name + boxIndex; if (InventoryManager.Instance.GetBoxDataListFromDick(key) != null) { _currentBagData.inventoryItemList = InventoryManager.Instance.GetBoxDataListFromDick(key); } else // 刷新时新建箱子 { InventoryManager.Instance.AddDataToBoxDict(this); } } 但是此时由于我们的每次切换场景的重建蓝图建筑都是直接调用的建造方法，在该方法中，如果检测到是一个Box，则会将其序号设置为dict的大小，而每次切换数据字典并不会改变，因此每次切换场景字典都在累加。\n为了解决这一问题，需要将ReBuildSceneFurniture()进行改写，且保证我们新建一个初始化一个box的时候，是先得到其对应的index，然后进行赋值\n1 2 3 4 public void BoxDataInit(int curIndex) { boxIndex = curIndex; string key = this.name + boxIndex; 修改重建函数：\n由于我们重建方法是遍历所有已经保存的SceneFurniture，因此我们需要在该class增加一个箱子的序号，并在每次生成的时候进行保存，那么在重建的时候，直接调用即可\n1 2 3 4 5 6 7 8 9 10 11 12 foreach (SceneFurniture item in currentFurnitureList) { BluePrintDetails bluePrintDetails = InventoryManager.Instance.bluePrintDataList.GetBluePrintDetails(item.bluePrintID); var BuildItem = Instantiate(bluePrintDetails.buildPrefab, item.itemPos.ToVector3(), Quaternion.identity, _itemParent.transform); /* 如果创建的物品是一个Box,那么需要为其设置Index值. 并初始化 */ if (BuildItem.GetComponent\u0026lt;Box\u0026gt;()) { BuildItem.GetComponent\u0026lt;Box\u0026gt;().BoxDataInit(item.boxIndex); } } 1 2 3 4 5 6 7 8 9 // itemManager.cs的获取所有场景蓝图建筑信息GetAllSceneFurniture()的修改内容 foreach (Furniture furniture in FindObjectsOfType\u0026lt;Furniture\u0026gt;()){ //.... if (furniture.GetComponent\u0026lt;Box\u0026gt;()) { newSceneFurniture.boxIndex = furniture.GetComponent\u0026lt;Box\u0026gt;().boxIndex; } } ","date":"2023-03-05T19:16:45+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%8D%81%E4%B8%80/","title":"麦田物语开发日记(十一)"},{"content":"制作游戏音效 创建声音数据结构，在不同场景出现不同音源 在MainCamera中有玩家能听到的音源，因此只需要保证在对应场景能正常切换不同音源即可。\n因此需要一个专门管理音源的控制器AudioManager，由于会出现环境音和背景音乐，因此在AudioManager下增加两个音源的控制器Game Music和Ambient Music，在两个音源控制器上需要一个音源组件Audio Source。\n由于不同动作触发的音效不同，且音调等内容都需要修改，因此需要一个特别的数据结构来存放所有音源SoundDetails\n除了管理音源的数据，还需要一个数据结构SceneSound来处理不同情况下使用的音源（包括背景音乐和环境音）。\n然后在切换场景的时候获得背景音等，然后调用播放函数\n声音数据结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [CreateAssetMenu(fileName = \u0026#34;SoundDetailsList_SO\u0026#34;, menuName = \u0026#34;Sound/SoundDetailsList\u0026#34;)] public class SoundDetailsList_SO : ScriptableObject { public List\u0026lt;SoundDetails\u0026gt; soundDetailsList; public SoundDetails GetSoundDetails(SoundName soundName) { return soundDetailsList.Find(s =\u0026gt; s.soundName == soundName); } } [System.Serializable] public class SoundDetails { public SoundName soundName; public AudioClip soundClip; /* 音源的特殊设定 */ [UnityEngine.Range(0.1f, 1.5f)] public float soundPitchMin; [UnityEngine.Range(0.1f, 1.5f)] public float soundPitchMax; [UnityEngine.Range(0.1f, 1f)] public float soundVolume; } 以上数据结构用于存放每个音乐名对应的音乐信息，即声音片段\n场景音乐管理数据结构\n该数据结构用于管理每个场景需要的所有音乐信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [CreateAssetMenu(fileName = \u0026#34;SceneSoundList_SO\u0026#34;, menuName = \u0026#34;Sound/SceneSoundList\u0026#34;)] public class SceneSoundList_SO : ScriptableObject { public List\u0026lt;SceneSoundItem\u0026gt; sceneSoundItemList; public SceneSoundItem GetSceneSoundItem(string sceneName) { return sceneSoundItemList.Find(s =\u0026gt; s.sceneName == sceneName); } } [System.Serializable] public class SceneSoundItem { [SceneName]public string sceneName; public SoundName ambientMusic; public SoundName sceneMusic; } 音乐管理控制器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class AudioManager : MonoBehaviour { [Header(\u0026#34;音乐库\u0026#34;)] public SoundDetailsList_SO soundDetailsData; public SceneSoundList_SO sceneSoundData; public AudioSource ambientSource; public AudioSource gameSource; private float MusicStartSecond =\u0026gt; Random.Range(3f, 5f); /* 播放音乐的等待时间 */ private Coroutine _soundRoutine; private void OnEnable() { EventHandler.AfterSceneLoadEvent += OnAfterSceneLoadEvent; } private void OnDisable() { EventHandler.AfterSceneLoadEvent -= OnAfterSceneLoadEvent; } #region 注册事件 private void OnAfterSceneLoadEvent() { /* 切换场景并获得当前场景的对应音乐 */ string sceneName = SceneManager.GetActiveScene().name; SceneSoundItem sceneSound = sceneSoundData.GetSceneSoundItem(sceneName); if (sceneSound == null) return; SoundDetails ambient = soundDetailsData.GetSoundDetails(sceneSound.ambientMusic); SoundDetails music = soundDetailsData.GetSoundDetails(sceneSound.sceneMusic); if (_soundRoutine != null) StopCoroutine(_soundRoutine); _soundRoutine = StartCoroutine(PlaySoundRoutine(music, ambient)); } #endregion #region 播放音乐 private IEnumerator PlaySoundRoutine(SoundDetails music, SoundDetails ambient) { if (music != null \u0026amp;\u0026amp; ambient != null) { PlayAmbientClip(ambient); yield return new WaitForSeconds(MusicStartSecond); PlayMusicClip(music); } } private void PlayMusicClip(SoundDetails soundDetails) { gameSource.clip = soundDetails.soundClip; if (gameSource.isActiveAndEnabled) gameSource.Play(); } private void PlayAmbientClip(SoundDetails soundDetails) { ambientSource.clip = soundDetails.soundClip; if (ambientSource.isActiveAndEnabled) ambientSource.Play(); } #endregion 在该管理代码中，主要是需要通过获得当前的场景信息来获取场景需要的音乐文件，然后将这些音乐文件赋值给音源管理组件，然后执行播放功能。\n在该部分使用了协程来保证切换场景后声音的等待时间出现。在此处如果要关闭一个特定的协程，需要先定义一个协程变量，然后关闭该协程，而生成则是直接赋值。\n1 2 3 if (_soundRoutine != null) StopCoroutine(_soundRoutine); _soundRoutine = StartCoroutine(PlaySoundRoutine(music, ambient)); 后续将通过额外的功能来无缝衔接音乐\n使用AudioMixer实现音效控制和转换 打开AudioMixer面板\nWindow栏-\u0026gt;AudioMixer\n创建AudioMixer\n在项目窗口中右键创建\nAudioMixer内容\nSnapshots可以作为某组音量内容的整体方案\nGroup用于管理音轨，子音轨收到父音轨管理\n如果需要通过代码控制音轨，则需要在音轨的Inspector中将音轨暴露出来，然后再音源中选择指定的音轨输出。\n然后在AudioManager.cs中使用AudioMixer组件来控制具体的音轨的数值\n代码修改部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private void PlayMusicClip(SoundDetails soundDetails, float transitionTime) { gameAudioMixer.SetFloat(\u0026#34;MusicVolume\u0026#34;, ConvertSoundVolume(soundDetails.soundVolume)); gameSource.clip = soundDetails.soundClip; if (gameSource.isActiveAndEnabled) gameSource.Play(); /* 切换到当前快照需要的时间 */ normalSnapshot.TransitionTo(transitionTime); } private void PlayAmbientClip(SoundDetails soundDetails, float transitionTime) { gameAudioMixer.SetFloat(\u0026#34;AmbientVolume\u0026#34;, ConvertSoundVolume(soundDetails.soundVolume)); ambientSource.clip = soundDetails.soundClip; if (ambientSource.isActiveAndEnabled) ambientSource.Play(); ambientSnapshot.TransitionTo(transitionTime); } 单个音效的增加 为了增加单个音效的，不能为每一个prefab添加音源，因此建立一个能够存放音源GO的线程池，每当得到一个GO的时候播放特定的音源。\n由于目前Unity自带对象池get音源prefab的方式有BUG，必须第二次get才能播放音效，因此需要使用传统的创建对象池的方法，即自己编写代码获取线程\n基础方法创建线程池 创建音源预制体\n创建音源预制体后，为其增加初始化控制代码\n1 2 3 4 5 6 7 8 9 10 11 12 [RequireComponent(typeof(AudioSource))] public class Sound : MonoBehaviour { [SerializeField] private AudioSource audioSource; public void SetAudio(SoundDetails soundDetails) { audioSource.clip = soundDetails.soundClip; audioSource.volume = AudioManager.Instance.ConvertSoundVolume(soundDetails.soundVolume); audioSource.pitch = Random.Range(soundDetails.soundPitchMin, soundDetails.soundPitchMax); } } 此时的audioSource是当前预制体自己的音源组件\n然后将该GO作为预制体存入PoolManager中，然后使用一个新的事件当触发播放音效的时候就获得线程池中的GO，并初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // PoolManager.cs /* 有BUG的方法 */ private void InitSoundEffect(ParticleEffectType effectType, SoundDetails soundDetails) { if (_poolEffectDic.ContainsKey(effectType.ToString())) { ObjectPool\u0026lt;GameObject\u0026gt; soundPool = _poolEffectDic[effectType.ToString()]; var soundObj = soundPool.Get(); soundObj.GetComponent\u0026lt;Sound\u0026gt;().SetAudio(soundDetails); StartCoroutine(ReleaseSoundRoutine(soundPool, soundObj, soundDetails)); } } private IEnumerator ReleaseSoundRoutine(ObjectPool\u0026lt;GameObject\u0026gt; pool,GameObject soundObj, SoundDetails soundDetails) { yield return new WaitForSeconds(soundDetails.soundClip.length); // 音乐长度 pool.Release(soundObj); } 设置事件触发\n建立事件\n1 2 3 4 5 6 7 8 // EventHandle.cs public static event Action\u0026lt;ParticleEffectType, SoundDetails\u0026gt; InitSoundEffectEvent; public static void CallInitSoundEffectEvent(ParticleEffectType particleEffectType, SoundDetails soundDetails) { InitSoundEffectEvent?.Invoke(particleEffectType, soundDetails); } 为Cropdetails设置音效名称，然后通过SoundManager.cs获得音效具体数据\n1 2 // dataCollection.cs [Space] [Header(\u0026#34;音效名称\u0026#34;)] public SoundName soundName; 为每一种作物添加音效（由于作物，石头，杂草的处理是分开的，因此添加音效也要在不同地方\n1 2 3 4 5 6 7 8 // Crop.cs /*音效*/ if (currentCropDetails.soundName != SoundName.None) { // 更新后的内容 EventHandler.CallPlaySoundEvent(currentCropDetails.soundName); var soundDetails = AudioManager.Instance.soundDetailsData.GetSoundDetails(currentCropDetails.soundName); EventHandler.CallInitSoundEffectEvent(ParticleEffectType.Sound, soundDetails); } 代码完成创建线程池的工作（解决Unity自带线程池问题）\n使用队列的方式，预先建造一个含有20个音源对象的队列，每次都从该队列中获取音源预制体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 使用队列自建线程池 */ /*初始化对象池*/ private void CreatSoundPool() { var soundParent = new GameObject(ParticleEffectType.Sound.ToString()).transform; soundParent.SetParent(transform); for (int i = 0; i \u0026lt; 20; i++) { GameObject obj = Instantiate(prefabList.Find(p =\u0026gt; p.name == ParticleEffectType.Sound.ToString()), soundParent); obj.SetActive(false); _soundQueue.Enqueue(obj); } } /*对象元素获取方法*/ private GameObject GetSoundPoolObj() { if (_soundQueue.Count \u0026lt; 2) CreatSoundPool(); return _soundQueue.Dequeue(); } private void InitSoundEffect(ParticleEffectType effectType, SoundDetails soundDetails) { if (_poolEffectDic.ContainsKey(effectType.ToString())) { var soundObj = GetSoundPoolObj(); soundObj.GetComponent\u0026lt;Sound\u0026gt;().SetAudio(soundDetails); soundObj.SetActive(true); StartCoroutine(ReleaseSoundObj(soundObj, soundDetails.soundClip.length)); } } private IEnumerator ReleaseSoundObj(GameObject obj, float duration) { yield return new WaitForSeconds(duration); obj.SetActive(false); _soundQueue.Enqueue(obj); } 增加脚步音效 为人物动画帧添加事件，然后该事件调用一个单独播放音效的事件，该事件由AudioManager注册，在该注册函数中会获取当前单独播放音效事件声音名称，然后获取音效内容，并呼叫真正的音效初始化事件(PoolManager注册)\n人物的动画事件\n1 2 3 4 5 6 7 public class AnimationEvent : MonoBehaviour { public void FootStepSound() { EventHandler.CallPlaySoundEvent(SoundName.FootStepSoft); } } 直接播放音效事件的注册，获得音效名称后，调用CallInitSoundEffectEvent事件，让PoolManager创建音效事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // AudioManager.cs /// \u0026lt;summary\u0026gt; /// 直接播放音效事件 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;soundName\u0026#34;\u0026gt;音效名称\u0026lt;/param\u0026gt; private void OnPlaySoundEvent(SoundName soundName) { SoundDetails soundDetails = soundDetailsData.GetSoundDetails(soundName); if (soundDetails is null) return; EventHandler.CallInitSoundEffectEvent(ParticleEffectType.Sound, soundDetails); } ","date":"2023-03-05T19:16:45+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%8D%81%E4%B8%89/","title":"麦田物语开发日记(十三)"},{"content":"TimeLine开场动画 创建TimeLine 打开Timeline面板 在菜单栏点击Window-\u0026gt;Sequnence-\u0026gt;Timeline\n为某一个GO添加Timeline组件 选中目标的GO，然后在Timeline窗口新建一个Timeline即可对选中的GO创建Timeline组件\n制作动画 将动画Canvas拖入Timeline栏并设置为Animation Track，使用Timeline窗口的录制功能即可实现动画录制\n一个技巧：先在靠后位置完成动画的结尾，保存当前场景所有内容的位置，颜色，打开状态、大小等，然后从前往后以此制作动画过程。\n为了保证动画在规定时间执行，因此可以将存放动画的Panel放入Timeline轴中，然后为期设置在动画节点才能启动\n创建Timeline对话 在出场动画结束后，执行开启强制执行的对话，因此必须将该部分也放在Timeline中，为了控制该部分内容，需要通过代码来控制Timeline。\n由于Timeline本身没有对话相关的轨道和片段，因此需要编写相应的脚本来创建对应的动画片段。相应的就需要设计轨道脚本DialogueTrack用于让Unity得知有自定义的轨道；轨道中的动画片段脚本DialogueClip，用于能够在轨道中创建动画片段，以及最主要的动画片段内容DialogueBehaviour，用于具体设计该动画需要呈现的内容。\n新建代码脚本DialogueBehaviour.cs，注意该类不是MonoBehaviour，而是PlayableBehaviour，\n该脚本能够控制我们整个对话播放过程的执行，暂停等\n1 2 3 4 5 6 7 8 9 10 11 public class DialogueBehaviour : PlayableBehaviour { private PlayableDirector _director; public DialoguePiece dialoguePiece; public override void OnPlayableCreate(Playable playable) { // 通过当前的播放的graph方向得到PlayableDirector _director = (playable.GetGraph().GetResolver() as PlayableDirector); } } 然后创建一个用于控制我们的每一条轨道的内容的代码DialogueClip，其需要继承两个特殊的接口PlayableAsset, ITimelineClipAsset\n其中PlayableAsset用于获得实例化的Playable的资源，也就是每一条轨道上的内容\nITimelineClipAsset是播放剪辑功能必备的组件\n1 2 3 4 5 6 7 8 9 10 11 12 public class DialogueClip : PlayableAsset, ITimelineClipAsset { public DialogueBehaviour dialogueTemplate = new DialogueBehaviour(); public override Playable CreatePlayable(PlayableGraph graph, GameObject owner) { /* 每次新建，都以dialogueTemplate为模板在graph中新建可以编辑的片段 */ var playable = ScriptPlayable\u0026lt;DialogueBehaviour\u0026gt;.Create(graph, dialogueTemplate); return playable; } public ClipCaps clipCaps =\u0026gt; ClipCaps.None; } 创建Timeline的Dialogue轨道，在该代码中，只需要让系统知道，你在该轨道中放的片段类型是什么，不需要实际的代码\n1 2 3 [TrackClipType(typeof(DialogueClip))] public class DialogueTrack : TrackAsset {} 从而得到以下内容\n然后为了显示具体的对话内容，需要对DialogueBehaviour中的部分方法进行重写，来执行该动画片段的具体内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class DialogueBehaviour : PlayableBehaviour { //.... public override void OnBehaviourPlay(Playable playable, FrameData info) { // 呼叫启动对话UI EventHandler.CallShowDialogueEvent(dialoguePiece); if (Application.isPlaying) { if (dialoguePiece.hasToPause) { // 暂停Timeline,等待按下空格 TimelineManager.Instance.PauseTimeline(_director); } else { // 关闭当前dialogue EventHandler.CallShowDialogueEvent(null); } } } } 由于设计对话的时候使用了 通过空格键在继续对话内容，因此为了实现对话持续需要继续增加按键播放。\n而等待空格键的过程中，Timeline必须停止，而且不能使用Timeline自带的暂停功能，其会导致暂停结束后快速播放后续内容，因此需要通过一个Timeline的控制器来控制其暂停。\n而控制暂停的方式就是让TimeLine的时间播放速度为0，当检测到空格则恢复播放\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class TimelineManager : Singleton\u0026lt;TimelineManager\u0026gt; { public PlayableDirector startDirector; /* 游戏开局的timeline */ private PlayableDirector _currentDirector; /* 当前正在播放的director */ private bool _isPause; protected override void Awake() { base.Awake(); _currentDirector = startDirector; } private void Update() { if (_isPause \u0026amp;\u0026amp; Input.GetKeyDown(KeyCode.Space)) { _currentDirector.playableGraph.GetRootPlayable(0).SetSpeed(1d); } } public void PauseTimeline(PlayableDirector director) { _currentDirector = director; /* 获得当前director中graph中的根节点， 并将其速度设置为0 */ _currentDirector.playableGraph.GetRootPlayable(0).SetSpeed(0d); _isPause = true; } } 控制Timeline启动与暂停 由于对话动画的播放并不是及时播放完成，因此上节代码按空格直接开启timeline的播放有误，本节将通过从Timeline自带的方法中获得对话是否播放完成的标志_isDone，通过该标志保证只有当对话动画播放完成才能启动timeline\n设置标志\n1 2 3 4 5 6 // timelineManager.cs private bool _isDone; public bool IsDone /* 为_isDone赋值 */ { set =\u0026gt; _isDone = value; } timeline播放时逐帧执行dialogpiece播放完成的赋值\n1 2 3 4 5 6 7 8 9 // DialogueBehaviou.cs /* 在timeline播放过程中逐帧执行 */ public override void ProcessFrame(Playable playable, FrameData info, object playerData) { if (Application.isPlaying) { TimelineManager.Instance.IsDone = dialoguePiece.isDone; } } 保证对话框的关闭\n由于OnBehaviourPlay方法只能在timeline执行的时候才能启动，因此如果timeline结束前有对话框，那么关闭对话框的代码就不能执行，因此需要在timeline结束以后也执行关闭对话框\n1 2 3 4 5 6 // DialogueBehaviou.cs /* 如果timeline最后是对话框，则强制关闭对话框 */ public override void OnBehaviourPause(Playable playable, FrameData info) { EventHandler.CallShowDialogueEvent(null); } 保证timeline开启的时候，游戏时间不会流逝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // DialogueBehaviou.cs /// \u0026lt;summary\u0026gt; /// 当当前对话开启的时候，游戏时间暂停 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;playable\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public override void OnGraphStart(Playable playable) { EventHandler.CallUpdateGameStateEvent(GameState.Pause); } public override void OnGraphStop(Playable playable) { EventHandler.CallUpdateGameStateEvent(GameState.Gameplay); } 修改时间流逝的内容\n1 2 3 4 5 // timeManager.cs private void OnUpdateGameStateEvent(GameState state) { _gameClockPause = state == GameState.Gameplay; } 获取当前场景内容\n1 2 3 4 5 6 7 // TimelineManager.cs private void OnAfterSceneLoadEvent() { _currentDirector = FindObjectOfType\u0026lt;PlayableDirector\u0026gt;(); if (_currentDirector != null) _currentDirector.Play(); } ","date":"2023-03-05T19:16:45+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%8D%81%E5%9B%9B/","title":"麦田物语开发日记(十四)"},{"content":"构建对话系统 构建对话UI的canvas，并完成内容显示 创建过程中需要注意如果要保证对话框内容主要是通过\n以下三个组件来控制\n创建对话数据实现对话逻辑 该部分的主要实现方式是构建一个专门记录对话信息的数据结构，然后可以用SO文件的方式来存储，也可以直接挂载到某个人物身上。当与人物触发对话的时候，就通过事件系统，不断将对话数据传递到对话的Canvas中，显示对应数据。\n对话数据结构构建 可以在每一个对话部分都构建一个事件，当对话完成后，可以直接调用事件，创造更多的内容\n1 2 3 4 5 6 7 8 9 10 11 [System.Serializable] public class DialoguePiece { [Header(\u0026#34;对话详情\u0026#34;)] public Sprite faceImage; public bool onLeft; /*人物头像的位置*/ public string characterName; [TextArea] public string dialogueText; public bool hasToPause; /* 是否需要停止，即还有下一句话 */ [HideInInspector]public bool isDone; /* 对话是否完成 */ // public UnityEvent afterDialogueEvent; /*对话完成后的事件*/ } 然后为每个NPC挂载操作对话数据的内容，然后使用栈来控制对话数据，如果数据需要被展示，则通过事件通知的方法，告诉DialogueUI显示对话内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 [RequireComponent(typeof(BoxCollider2D))] [RequireComponent(typeof(NpcMovement))] public class DialogueController : MonoBehaviour { public List\u0026lt;DialoguePiece\u0026gt; dialoguePieces = new List\u0026lt;DialoguePiece\u0026gt;(); private NpcMovement NpcMovement =\u0026gt; GetComponent\u0026lt;NpcMovement\u0026gt;(); public UnityEvent onFinishEvent; private Stack\u0026lt;DialoguePiece\u0026gt; _dialoguePieceStack = new Stack\u0026lt;DialoguePiece\u0026gt;(); private bool _canTalk; private bool _isTalking; /* 防止生成过多协程 */ private GameObject _uiSign; private void Awake() { _uiSign = transform.GetChild(1).gameObject; FillDialogueStack(); } private void OnTriggerEnter2D(Collider2D other) { if (other.CompareTag(\u0026#34;Player\u0026#34;)) { _canTalk = !NpcMovement.isMoving \u0026amp;\u0026amp; NpcMovement.interactable; } } private void OnTriggerExit2D(Collider2D other) { if (other.CompareTag(\u0026#34;Player\u0026#34;)) { _canTalk = false; } } private void Update() { _uiSign.SetActive(_canTalk); if (Input.GetKeyDown(KeyCode.Space) \u0026amp;\u0026amp; _canTalk \u0026amp;\u0026amp; !_isTalking) { StartCoroutine(DialogueRoutine()); } } /// \u0026lt;summary\u0026gt; /// 填充对话 /// \u0026lt;/summary\u0026gt; private void FillDialogueStack() { /* 由于是入栈，因此采用倒序的方式 */ for (int i = dialoguePieces.Count - 1; i \u0026gt;= 0; i--) { dialoguePieces[i].isDone = false; _dialoguePieceStack.Push(dialoguePieces[i]); } } private IEnumerator DialogueRoutine() { _isTalking = true; if (_dialoguePieceStack != null \u0026amp;\u0026amp; _dialoguePieceStack.Count \u0026gt; 0) { if (_dialoguePieceStack.TryPop(out DialoguePiece result)) { /* 将结果发送到UI界面更新UI */ EventHandler.CallShowDialogueEvent(result); yield return new WaitUntil(() =\u0026gt; result.isDone); /* 直到点击空格，才能显示后续内容 */ _isTalking = false; } } else { EventHandler.CallShowDialogueEvent(null); FillDialogueStack(); _isTalking = false; onFinishEvent?.Invoke(); } } } 为UI显示内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 public class DialogueUI : MonoBehaviour { public GameObject dialogueBox; public Text dialogueText; public Image faceRight, faceLeft; public TextMeshProUGUI nameRight, nameLeft; public GameObject continueBox; private void Awake() { dialogueBox.SetActive(false); continueBox.SetActive(false); } private void OnEnable() { EventHandler.ShowDialogueEvent += OnShowDialogueEvent; } private void OnDisable() { EventHandler.ShowDialogueEvent -= OnShowDialogueEvent; } #region 注册事件 private void OnShowDialogueEvent(DialoguePiece piece) { StartCoroutine(ShowDialogue(piece)); } #endregion #region 显示对话窗口 /* 由于要文字一点一点打出来，因此需要使用协程方法 */ private IEnumerator ShowDialogue(DialoguePiece piece) { if (piece is not null) { piece.isDone = false; dialogueBox.SetActive(true); continueBox.SetActive(false); dialogueText.text = String.Empty; if (piece.characterName != String.Empty) { faceLeft.gameObject.SetActive(piece.onLeft); faceRight.gameObject.SetActive(!piece.onLeft); if (piece.onLeft) { faceLeft.sprite = piece.faceImage; nameLeft.text = piece.characterName; } else { faceRight.sprite = piece.faceImage; nameRight.text = piece.characterName; } } else { faceLeft.gameObject.SetActive(false); faceRight.gameObject.SetActive(false); nameLeft.gameObject.SetActive(false); nameRight.gameObject.SetActive(false); } /*等当前语句执行结束才能继续下一步*/ yield return dialogueText.DOText(piece.dialogueText, 1f).WaitForCompletion(); piece.isDone = true; if (piece.hasToPause \u0026amp;\u0026amp; piece.isDone) continueBox.SetActive(true); else continueBox.SetActive(true); } else { dialogueBox.SetActive(false); yield break; } } #endregion } 实现物品交易 以角色背包为基础，设计一个通用背包的UI，该UI以内容完全自适应为基础，即背包的大小会随着内容的大小而改变，因此每次都需要重新生成物品内容的slot.\n如果父物体设置了Vertical Layout Group，但是子物体向摆脱父物体的自适应，则需要为子物体设置LayoutElement，然后选择忽略布局。\n然后再InventoryUI中设置需要的变量，为通用背包赋值\n1 2 3 [Header(\u0026#34;通用背包\u0026#34;)] [SerializeField] private GameObject baseBag; public GameObject shopSlotPrefab; [SerializeField] private List\u0026lt;SlotUI\u0026gt; baseBagSlots; 设置对话结束事件，为用户打开商店做准备，由于通知NPC打开背包是再NPC身上调用的，因此还是需要通过事件的方式来触发打开背包，然后让Inventory来注册背包打开的函数。最后在完成对话后直接调用该事件即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class NpcFunction : MonoBehaviour { public InventoryBag_SO shopData; private bool _isOpen; private void Update() { if (Input.GetKeyDown(KeyCode.Escape) \u0026amp;\u0026amp; _isOpen) { _isOpen = false; // 关闭背包 } } public void OpenShop() { _isOpen = true; EventHandler.CallBaseBagOpenEvent(SlotType.Shop, shopData); } } inventoryUI打开商店事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void OnBaseBagOpenEvent(SlotType slotType, InventoryBag_SO bagSo) { GameObject slotPrefab = slotType switch { SlotType.Shop =\u0026gt; shopSlotPrefab, _ =\u0026gt; null }; baseBag.SetActive(true); for (int i = 0; i \u0026lt; bagSo.inventoryItemList.Count; i++) { SlotUI slot = Instantiate(slotPrefab, baseBag.transform.GetChild(1)).GetComponent\u0026lt;SlotUI\u0026gt;(); slot.slotIndex = i; baseBagSlots.Add(slot); } /* 强制更新界面 */ LayoutRebuilder.ForceRebuildLayoutImmediate(baseBag.GetComponent\u0026lt;RectTransform\u0026gt;()); /* 更新格子 */ OnUpdateInventoryUI(InventoryLocation.Shop, bagSo.inventoryItemList); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 更新界面的方法 case InventoryLocation.Shop: for (int i = 0; i \u0026lt; items.Count; i++) { if (items[i].itemAmount \u0026gt; 0) { // 获得需要更新的物体的具体信息 var itemDetails = InventoryManager.Instance.GetItemDetails(items[i].itemID); baseBagSlots[i].UpdateSlot(itemDetails, items[i].itemAmount); } else { baseBagSlots[i].UpdateEmptySlot(); } } break; 强制更新UI界面需要使用\n1 LayoutRebuilder.ForceRebuildLayoutImmediate(baseBag.GetComponent\u0026lt;RectTransform\u0026gt;()); 实现物品交易结束以及拖拽交易 交易结束 注册交易结束事件，然后点击关闭的时候调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 // inventory中注册的关闭事件的方法 private void OnBaseBagCloseEvent(SlotType slotType, InventoryBag_SO bagSo) { baseBag.SetActive(false); itemTooltip.gameObject.SetActive(false); UpdateSlotHighlight(-1); foreach (var slot in baseBagSlots) { Destroy(slot.gameObject); } baseBagSlots.Clear(); } 使用不同的状态来表示游戏的运行状态（GamePlay和Pause） 1 2 3 4 5 6 public static event Action\u0026lt;GameState\u0026gt; UpdateGameStateEvent; public static void CallUpdateGameStateEvent(GameState gameState) { UpdateGameStateEvent?.Invoke(gameState); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // player.cs中注册人物移动 private void OnUpdateGameStateEvent(GameState gameState) { switch (gameState) { case GameState.Gameplay: _inputDisable = false; break; case GameState.Pause: _inputDisable = true; break; } } 然后在不同的需要控制玩家点击和不能移动的地方调用该事件\n强制打开Player的背包 保证打开人物背包的时候修改背包的锚点位置即可\n1 2 3 4 5 6 7 /* Inventory.cs 中OnBaseBagOpenEvent()打开人物背包 */ if (slotType == SlotType.Shop) { bagUI.GetComponent\u0026lt;RectTransform\u0026gt;().pivot = new(-1, 0.5f); bagUI.SetActive(true); bagOpened = true; } 实现拖拽交易 在slotUI拖拽的位置设置对应的处理事件，然后触发交易UI，然后根据交易UI的具体内容，和是否贩卖的标志来完成具体的交易内容\n1 2 3 4 5 6 7 8 9 10 11 // SlotUI.cs // OnEndDrag()方法中 /* 物品买卖 */ else if (slotType == SlotType.Shop \u0026amp;\u0026amp; targetSlot.slotType == SlotType.Bag) { EventHandler.CallShowTradeUIEvent(slotItemDetails, false); } else if (slotType == SlotType.Bag \u0026amp;\u0026amp; targetSlot.slotType == SlotType.Shop) { EventHandler.CallShowTradeUIEvent(slotItemDetails, true); } 然后构造交易UI\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class TradeUI : MonoBehaviour { public Image itemIcon; public Text itemName; public InputField tradeAmount; public Button submitBtn; public Button cancelBtn; private ItemDetails _itemDetails; private bool _isSellTrade; private void Awake() { cancelBtn.onClick.AddListener(CancelTrade); } public void SetTradeUI(ItemDetails item, bool isSell) { this._itemDetails = item; itemIcon.sprite = item.itemIcon; itemName.text = item.itemName; _isSellTrade = isSell; tradeAmount.text = string.Empty; } public void CancelTrade() { this.gameObject.SetActive(false); } } 注意在此过程中需要随时根据具体情况修改游戏运行状态\n实现交易过程 在InventoryManager中实现交易的具体过程，即对玩家的金钱和物品内容的处理，然后更新UI，然后在UI界面注册对该方法的执行。\n具体的交易执行方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public void TradeItem(ItemDetails item, bool isSell, int tradeAmount) { /* 计算金额 */ int totalCost = item.itemPrice * tradeAmount; int realCost = 0; /* 获得背包位置，检测背包是否有当前物品 */ int itemIndexId = GetItemIndexInBag(item.itemID); // 如果没有返回-1 if (isSell) { // 有足够的物品才卖出 if (itemIndexId != -1 \u0026amp;\u0026amp; playerBag.inventoryItemList[itemIndexId].itemAmount \u0026gt;= tradeAmount) { RemoveItem(item.itemID, tradeAmount); realCost = (int)(totalCost * item.sellPercentage); playerCash += realCost; } } else { if (playerCash \u0026gt;= totalCost \u0026amp;\u0026amp; CheckBagCapacity() != -1) { playerCash -= totalCost; AddItemInIndex(item.itemID, itemIndexId , tradeAmount); } } EventHandler.CallUpdateInventoryUI(InventoryLocation.Player, playerBag.inventoryItemList); } 然后在TradeUI.cs中实现对上述执行方法的调用\n1 2 3 4 5 6 7 private void TradeItem() { /* 将文本转化为具体需要执行的数值 */ var amount = Convert.ToInt32(tradeAmount.text); InventoryManager.Instance.TradeItem(_itemDetails, _isSellTrade, amount); } 该方法需要通过对btn绑定监听器\n1 submitBtn.onClick.AddListener(TradeItem); 最后注意更新玩家的金钱即可。\n","date":"2023-03-05T19:16:44+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%8D%81/","title":"麦田物语开发日记(十)"},{"content":"Astar算法实现NPC自动寻路 构建Astar数据结构 构建Astar算法数据结构的主要内容就是构造每个节点代价值Node.cs，然后为整个地图设置一个脚本GridNodes.cs，用于将整个地图的所有瓦片进行设置。\n由于瓦片地图的坐标是以中心为(0, 0)节点的，因此获得瓦片地图的坐标需要从左下角原点位置获取。因此需要在MapData_SO文件中设置每个场景地图的坐标\nNode.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Node : IComparable\u0026lt;Node\u0026gt; { private Vector2Int _gridPos; // 当前节点的网格坐标 private int _gCost = 0; /* 当前节点距离起始点的距离 */ private int _hCost = 0; /* 当前节点距离重点的距离 */ private bool _isObsticle = false; private Node _parentNode = null; public Node(Vector2Int pos) { _gridPos = pos; _parentNode = null; } private int FCost =\u0026gt; _gCost + _hCost; // 当前节点的值更大，则返回1，小就返回-1，相等返回0 public int CompareTo(Node other) { if (FCost == other.FCost) { return _hCost.CompareTo(other._hCost); } return FCost.CompareTo(other.FCost); } } GridNodes.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class GridNodes { /* 将瓦片地图的信息全部汇总 */ private int _width; private int _height; private Node[,] _gridNode; //每个坐标下的节点信息 public GridNodes(int width, int height) { _width = width; _height = height; for (int x = 0; x \u0026lt; width; x++) { for (int y = 0; y \u0026lt; height; y++) { _gridNode[x, y] = new Node(new Vector2Int(x, y)); } } } public Node GatGridNode(int x, int y) { if (x \u0026gt; _width || y \u0026gt; _height) { Debug.Log(\u0026#34;超出网格信息\u0026#34;); return null; } return _gridNode[x, y]; } } 根据每个地图信息生成节点数据 新建一个专门用于挂载到NPC的脚本AStar.cs，该脚本用于规划NPC的路径，因此该基本需要知道当前场景的所有基本信息\n首先需要先获得当前场景的地图大小，因此要从GridMapManager.cs中获取地图的相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public bool GetGridDimensions(string sceneName, out Vector2Int gridDimension, out Vector2Int originPos) { /* 对当前场景数据进行初始化 */ gridDimension = Vector2Int.zero; originPos = Vector2Int.zero; foreach (var mapData in mapDataSos) { if (sceneName == mapData.sceneName) { gridDimension = new Vector2Int(mapData.wight, mapData.height); originPos = new Vector2Int(mapData.originX, mapData.originY); return true; } } return false; } 然后需要处理AStar的所有网格信息，保存每个网格中能够找到所有的NPC的障碍物, 因此首先要初始化整个Astar算法的所有相关信息，然后去获得最短路径，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 private GridNodes _gridNodes; private Node _startNode; private Node _endNode; private Vector2Int _gridArea; private Vector2Int _originPos; private List\u0026lt;Node\u0026gt; _openNodeList; /* 当前待遍历的节点列表*/ private HashSet\u0026lt;Node\u0026gt; _closedNodeList; /* 已经被遍历过的节点列表 */ private bool _pathFound; /* 已经找到最短路径的标志量 */ private int[,] _direction = new int[,] { { 1, 1 }, { 1, 0 }, { 1, -1 }, { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, 1 }, { 0, -1 } }; public void BuildPath(string sceneName, Vector2Int startPos, Vector2Int endPos) { /* 初始化当前场景的信息 */ _pathFound = false; if (GenerateGridNodes(sceneName, startPos, endPos)) { /* 找出最短路径 */ if (FindShortestPath()) { /* 移动NPC */ } } } /// \u0026lt;summary\u0026gt; /// 构建网格信息，初始化两个列表 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sceneName\u0026#34;\u0026gt;当前场景名称\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;startPos\u0026#34;\u0026gt;NPC的起始网格\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;endPos\u0026#34;\u0026gt;NPC的目标网格\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private bool GenerateGridNodes(string sceneName, Vector2Int startPos, Vector2Int endPos) { /* 获得加载地图的场景信息 */ if (GridMapManager.Instance .GetGridDimensions(sceneName, out Vector2Int gridDimension, out Vector2Int originPos)) { _gridArea = gridDimension; _originPos = originPos; _openNodeList = new List\u0026lt;Node\u0026gt;(); _closedNodeList = new HashSet\u0026lt;Node\u0026gt;(); GridNodes curGridNodes = new GridNodes(gridDimension.x, gridDimension.y); } else { return false; } /* 将起始点和终点换算成节点矩阵坐标 */ var convertStart = AStarConvert(startPos, AStarConvertType.CellToNodes); var convertEnd = AStarConvert(endPos, AStarConvertType.CellToNodes); _startNode = _gridNodes.GetGridNode(convertStart.x, convertStart.y); _endNode = _gridNodes.GetGridNode(convertEnd.x, convertEnd.y); /* 将GridNodes中每一个节点都初始化 */ for (int x = 0; x \u0026lt; _gridArea.x; x++) { for (int y = 0; y \u0026lt; _gridArea.y; y++) { var curCell = AStarConvert(new Vector2Int(x, y), AStarConvertType.NodesToCell); Vector3Int tilePOS = new Vector3Int(curCell.x, curCell.y, 0); // 获得当前瓦片的障碍信息 TileDetails curTile = GridMapManager.Instance.GetTileDetailsByMousePos(tilePOS); _gridNodes.GetGridNode(x, y).SetObstacle(); } } return true; } private bool FindShortestPath() { /* 使用最短路径算法 找出最短路径 */ _openNodeList.Add(_startNode); while (!_pathFound \u0026amp;\u0026amp; _openNodeList.Count \u0026gt; 0) { _openNodeList.Sort(); // 桶排序，升序排序 var closeNode = _openNodeList[0]; _openNodeList.RemoveAt(0); if (closeNode == _endNode) { _pathFound = true; break; } /* 将closeNode周围的点分别存入openNodeList中 */ AddNeighborOfCloseNode(closeNode); _closedNodeList.Add(closeNode); } return _pathFound; } 评估周围节点的代价 也就是获得节点的权重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /// \u0026lt;summary\u0026gt; /// 评估周围八个点 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;closeNode\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void AddNeighborOfCloseNode(Node closeNode) { Vector2Int curPos = closeNode.GetPos(); for (int x = -1; x \u0026lt;= 1; x++) { for (int y = -1; y \u0026lt;= 1; y++) { if (x == 0 \u0026amp;\u0026amp; y == 0) continue; var nextPosX = curPos.x + x; var nextPosY = curPos.y + y; var validNeighbourNode = GetValidNeighbourNode(nextPosX, nextPosY); if (validNeighbourNode != null \u0026amp;\u0026amp; !_openNodeList.Contains(validNeighbourNode)) { /* 计算代价 */ validNeighbourNode.gCost = closeNode.gCost + GetDistance(closeNode, validNeighbourNode); validNeighbourNode.hCost = GetDistance(validNeighbourNode, _endNode); validNeighbourNode.parentNode = closeNode; _openNodeList.Add(validNeighbourNode); } } } } private Node GetValidNeighbourNode(int x, int y) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= _gridArea.x || y \u0026gt;= _gridArea.y) { return null; } Node neighbourNode = _gridNodes.GetGridNode(x, y); if (neighbourNode.isObsticle || _closedNodeList.Contains(neighbourNode)) return null; return neighbourNode; } private int GetDistance(Node nodeA, Node nodeB) { int disX = Mathf.Abs(nodeA.GetPos().x - nodeB.GetPos().x); int disY = Mathf.Abs(nodeA.GetPos().y - nodeB.GetPos().y); // 如果X更大，那么说明要往x方向先走(disX - disY)步，才能斜方向走。 if (disX \u0026gt; disY) { return (disX - disY) * 10 + disY * 14; } else { return (disY - disX) * 10 + disX * 14; } } 在地图上绘制测试用的最短路径算法 由于已经得到最短路径，因此只需要为NPC设置每一步要走的位置。而获得位置的方法则是通过一个栈去不断迭代得到节点父节点，然后保存起来。\n而NPC每个位置的节点需要用一个专门的数据结构保存下来\n1 2 3 4 5 6 7 8 9 public class MovementStep { public string sceneName; public int hour; public int minutes; public int seconds; public Vector2Int gridCoordinate; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// \u0026lt;summary\u0026gt; /// 构建NPC移动的节点栈 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sceneName\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;npcMovementStep\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void UpdatePathOnMovementStepStack(string sceneName, Stack\u0026lt;MovementStep\u0026gt; npcMovementStep) { Node nextNode = _endNode; while (nextNode != null) { npcMovementStep.Push(new MovementStep() { sceneName = sceneName, gridCoordinate = AStarConvert(nextNode.GetPos(), AStarConvertType.NodesToCell) }); nextNode = nextNode.parentNode; } } 然后在统管整个Astar算法的方法中，执行上述方法，就能得到NPC的移动路径。\n因此需要创建一个用于管理所有NPC移动的NPCMnager，然后挂载对应的Astar算法，同时挂载一个用于测试的脚本，该脚本需要通过瓦片地图绘制路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class AStarTest : MonoBehaviour { private AStar _aStar; [Header(\u0026#34;测试点\u0026#34;)] public Vector2Int startPos; public Vector2Int endPos; [Header(\u0026#34;显示路径\u0026#34;)] public bool displayNode; public bool displayPath; [Header(\u0026#34;绘制工具\u0026#34;)] public Tilemap displayMap; public TileBase tile; private Stack\u0026lt;MovementStep\u0026gt; _npcMovementStack; private void Awake() { _aStar = GetComponent\u0026lt;AStar\u0026gt;(); _npcMovementStack = new Stack\u0026lt;MovementStep\u0026gt;(); } private void Update() { ShowPathOnGridMap(); } private void ShowPathOnGridMap() { if (displayMap == null || tile == null) return; if (displayNode) { displayMap.SetTile((Vector3Int)startPos, tile); displayMap.SetTile((Vector3Int)endPos, tile); } else { displayMap.SetTile((Vector3Int)startPos, null); displayMap.SetTile((Vector3Int)endPos, null); } if (displayPath) { _aStar.BuildPath(SceneManager.GetActiveScene().name, startPos, endPos, _npcMovementStack); foreach (var step in _npcMovementStack) { displayMap.SetTile((Vector3Int)step.gridCoordinate, tile); } } else { if (_npcMovementStack.Count \u0026gt; 0) { foreach (var step in _npcMovementStack) { displayMap.SetTile((Vector3Int)step.gridCoordinate, null); } } } } } 制作NPC基本信息，并实现场景切换 该部分主要由NpcMovement代码来控制Npc的移动和场景切换，该部分主要控制NPC移动相关的基本信息，以及其是否能出现在某个场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 [RequireComponent(typeof(Animator))] [RequireComponent(typeof(Rigidbody2D))] public class NpcMovement : MonoBehaviour { /* 临时信息 */ [SerializeField] private string currentScene; private string _targetScene; private Vector3Int _currentScenePos; private Vector3Int _targetScenePos; public string StartScene { set { currentScene = value; } } [Header(\u0026#34;移动属性\u0026#34;)] public float normalSpeed = 2f; public float minSpeed = 1f; public float maxSpeed = 3f; private Vector2 _dir; private bool _isMoving; /* 挂载组件 */ private Rigidbody2D _rb; private Animator _animator; private SpriteRenderer _sprite; private BoxCollider2D _collider2D; private Stack\u0026lt;MovementStep\u0026gt; _movementSteps; private void Awake() { _rb = GetComponent\u0026lt;Rigidbody2D\u0026gt;(); _animator = GetComponent\u0026lt;Animator\u0026gt;(); _sprite = GetComponent\u0026lt;SpriteRenderer\u0026gt;(); _collider2D = GetComponent\u0026lt;BoxCollider2D\u0026gt;(); } private void OnEnable() { EventHandler.AfterSceneLoadEvent += OnAfterSceneLoadEvent; } private void OnDisable() { EventHandler.AfterSceneLoadEvent -= OnAfterSceneLoadEvent; } #region 注册事件 private void OnAfterSceneLoadEvent() { CheckNpcVisible(); } #endregion private void CheckNpcVisible() { if (currentScene == SceneManager.GetActiveScene().name) SetActiveInScene(); else SetInActiveInScene(); } #region 设置NPC显示情况 private void SetActiveInScene() { _sprite.enabled = true; _collider2D.enabled = true; /* 显示阴影 */ // transform.GetChild(0).gameObject.SetActive(true); } private void SetInActiveInScene() { _sprite.enabled = false; _collider2D.enabled = false; /* 显示阴影 */ // transform.GetChild(0).gameObject.SetActive(false); } #endregion Schedule 数据制作和路径生成 由于NPC是在网格中进行移动，因此需要先将NPC初始化到地图的网格中（初始化方法）。\n然后设计一个SceduleDetails来在什么时间段，NPC应该出现在那个场景，做什么动作，因此在具体的控制代码中，需要用一个List来控制这些数据。\n然后我们需要根据Scedule来生成NPC的行走路径，而路径需要每一步都有一个时间戳，因此在生成路径的时候需要使用TimeSpan来控制在路径过程中，每一步的时间。\n使用TimeSpan的时候需要在TimeManager中为其设置值，因为其需要游戏系统设置的时间\n在NpcMoveMent.cs初始化Npc的位置信息 1 2 3 4 5 6 7 8 9 10 private void InitNpc() { _targetScene = currentScene; /* 保证npc初始化的时候在网格中心点 */ _currentScenePos = _gird.WorldToCell(transform.position); transform.position = new Vector3(_currentScenePos.x + Settings.gridCellSize / 2, _currentScenePos.y + Settings.gridCellSize / 2); _targetScenePos = _currentScenePos; } 使用一个初始化标志量来确保，每次加载场景时，只有第一个能够调用这个方法\n设计NPC的行程数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 [Serializable] public class ScheduleDetails : IComparable\u0026lt;ScheduleDetails\u0026gt; { public int hour, minute, day; public int priority; public Season season; public string targetSceneName; public Vector2Int targetGridPosition; public AnimationClip clipAtStop; /* 移动结束后停留动作 */ public bool interactable; public ScheduleDetails(int hour, int minute, int day, int priority, Season season, string targetSceneName, Vector2Int targetGridPosition, AnimationClip clipAtStop, bool interactable) { this.hour = hour; this.minute = minute; this.day = day; this.priority = priority; this.season = season; this.targetSceneName = targetSceneName; this.targetGridPosition = targetGridPosition; this.clipAtStop = clipAtStop; this.interactable = interactable; } public int Time =\u0026gt; hour * 100 + minute; public int CompareTo(ScheduleDetails other) { if (Time == other.Time) { return priority - other.priority; } else { return Time - other.Time; } return 0; } } 并设计对应的DataSO文件，保证该数据能够被每一个NPC的Movement.cs文件调用\n为NPC生成路径生成算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public ScheduleDataList_SO scheduleData; private SortedSet\u0026lt;ScheduleDetails\u0026gt; _scheduleDetailsSet; private ScheduleDetails _curSchedule; private void BuildPath(ScheduleDetails schedule) { /* 为堆栈中的每一步生成时间 */ _movementSteps.Clear(); _curSchedule = schedule; if (schedule.targetSceneName == currentScene) { AStar.AStar.Instance.BuildPath(schedule.targetSceneName, (Vector2Int)_currentScenePos, schedule.targetGridPosition, _movementSteps); } else { } if (_movementSteps.Count \u0026gt;= 1) { // 更新每一步的时间戳 UpdateTimeOnPath(); } } 在这一过程中需要为每一步都生成一个时间戳，通过这个时间戳能够在后续时间更新时，NPC到达指定位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private void UpdateTimeOnPath() { MovementStep previousStep = null; TimeSpan currentGameTime = GameTime; foreach (MovementStep step in _movementSteps) { if (previousStep == null) { previousStep = step; } step.hour = currentGameTime.Hours; step.minutes = currentGameTime.Minutes; step.seconds = currentGameTime.Seconds; var nextStepDis =MoveInDiagonal(step, previousStep) ? Settings.gridCellSize : Settings.gridCellDiagonalSize; /* 计算下一步的时间 */ TimeSpan gridMovementStepTime = new TimeSpan(0, 0, (int) (nextStepDis / normalSpeed / Settings.GameSecondHold)); currentGameTime = currentGameTime.Add(gridMovementStepTime); // 下一步的时间 previousStep = step; } } 注意在使用TimeSpan的时候需要在TimeManager中进行初始化，然后通过的单例模式的方法获得该数值\n1 2 3 4 5 // TimeManager.cs public TimeSpan GameTime =\u0026gt; new TimeSpan(_gameHours, _gameMinutes, _gameSeconds); // NpcMoveMent.cs private TimeSpan GameTime =\u0026gt; TimeManager.Instance.GameTime; 实现NPC使用Astar算法移动 设计NPC的移动逻辑，然后放在FixedUpdate中进行调用，只要当前Npc的移动堆栈中存在数据，那么就让NPC进行移动。因此后续只需要为NPC创建路径，那么其到时候会随着帧数更新而移动。\n在控制移动的过程中，需要先判断当前NPC是否正在移动，如果不在，则检测其是否到达了移动时间（到达时间则生成路径），如果有路径则让其开始移动，此时先检查NPC的移动是同场景移动还是不同场景的移动，如果不是同场景，则不予显示。\n在正式移动的过程中先计算出其能否在规定时间内移动到目标位置，也就是利用距离和时间的比值，如果不行则直接瞬移过去，如果行则目标速度移动过去。\n同时移动通过协程的方法，不断计算移动方向和移动的距离，使用rigidBody进行移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 /// \u0026lt;summary\u0026gt; /// 控制移动的方法 /// \u0026lt;/summary\u0026gt; private void Movement() { if (!_npcMove) { if (_movementSteps.Count \u0026gt; 0) { MovementStep step = _movementSteps.Pop(); currentScene = step.sceneName; CheckNpcVisible(); _targetScenePos = (Vector3Int)step.gridCoordinate; /* 根据当前的时间和每一步的时间戳完成移动 */ TimeSpan stepTime = new TimeSpan(step.hour, step.minutes, step.seconds); MoveToTargetGrid((Vector3Int)step.gridCoordinate, stepTime); } } } private void MoveToTargetGrid(Vector3Int stepPos, TimeSpan stepTime) { /* 使用协程完成移动 */ StartCoroutine(MoveRoutine(stepPos, stepTime)); } /// \u0026lt;summary\u0026gt; /// 具体的移动函数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;stepPos\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;stepTime\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private IEnumerator MoveRoutine(Vector3Int stepPos, TimeSpan stepTime) { _npcMove = true; _nextStepWorldPos = GetWorldPosition(stepPos); /* 判断在有限时间内是否能通过行走到达指定位置 */ if (stepTime \u0026gt; GameTime) { /* 计算移动位置的世界坐标，然后用rigidBody进行移动 */ float timeMove = (float)(stepTime.TotalSeconds - GameTime.TotalSeconds); float distance = Vector3.Distance(_nextStepWorldPos, transform.position); float neededSpeed = Mathf.Min(minSpeed, (float)(distance / timeMove / Settings.GameTimeThreshold)); if (neededSpeed \u0026lt;= maxSpeed) { /* 能够正常走到目标网格，那么判断像素距离是否达标 */ while (Vector3.Distance(transform.position, _nextStepWorldPos) \u0026gt; Settings.pixelSize) { _dir = (_nextStepWorldPos - transform.position).normalized; /* 计算位移 */ Vector2 posOffset = new Vector2(neededSpeed * _dir.x * Time.fixedTime, neededSpeed * _dir.y * Time.fixedTime); _rb.MovePosition(_rb.position + posOffset); yield return new WaitForFixedUpdate(); } } } /*如果没有时间，或者正常达到，都是瞬移到目标位置*/ _rb.position = _nextStepWorldPos; _currentScenePos = stepPos; _nextStepWorldPos = _currentScenePos; _npcMove = false; } private Vector3 GetWorldPosition(Vector3Int curGridPos) { return _gird.WorldToCell(curGridPos) + new Vector3(Settings.gridCellSize / 2, Settings.gridCellSize / 2, 0); } 该部分的测试工作，则是新建一个schedual，然后构建对应的path即可。 制作NPC动画并完成按照日程表触发 在动画控制界面，由于我们默认的动画控制器是AnimatorController,而人物从空白动画切换到停止动画需要通过AnimatorOverrideController进行控制，因此需要使用上转的方式将当前运行的RuntimeAnimatorController改为AnimatorOverrideController，然后再修改动画片段。\n初始化过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* 动画计时器 */ private float _animationDelayTime; private bool _canPlayStopAnimation; private AnimationClip _stopAnimationClip; public AnimationClip blankAnimationClip; private AnimatorOverrideController _animatorOverride; private void Awake() { // ... /* 修改动画的播放 */ _animatorOverride = new AnimatorOverrideController(_animator.runtimeAnimatorController); _animator.runtimeAnimatorController = _animatorOverride; } // 移动结束的动画 private IEnumerator SetStopAnimation() { /* 设置停止后的面向方位 */ _animator.SetFloat(\u0026#34;DirX\u0026#34;, 0); _animator.SetFloat(\u0026#34;DirY\u0026#34;, -1); _animationDelayTime = Settings.AnimationDelayTime; if (_canPlayStopAnimation \u0026amp;\u0026amp; _stopAnimationClip != null) { /* 修改_animatorOverride,此时其已经成为运行时动画 */ _animatorOverride[blankAnimationClip] = _stopAnimationClip; _animator.SetBool(\u0026#34;EventAnimation\u0026#34;, true); yield return null; _animator.SetBool(\u0026#34;EventAnimation\u0026#34;, false); } else { _animatorOverride[_stopAnimationClip] = blankAnimationClip; } } 同时需要在moveMent方法中增加当没有移动，并可以播放停止动画时候的判断\n1 2 3 4 5 6 7 8 if (_movementSteps.Count \u0026gt; 0) { //... } else if (!_isMoving \u0026amp;\u0026amp; _canPlayStopAnimation) { StartCoroutine(SetStopAnimation()); } 利用时间推移的事件来触发NPC行程 先注册事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 private void OnEnable() { // .. EventHandler.GameMinuteEvent += OnGameMinuteEvent; } private void OnDisable() { // .. EventHandler.GameMinuteEvent += OnGameMinuteEvent; } private void OnGameMinuteEvent(int min, int hour, int day, Season season) { int curTime = 100 * hour + min; _curSeason = season; ScheduleDetails matchSchedule = null; /* 与当前时间段匹配的行程 */ foreach (ScheduleDetails scheduleDetails in _scheduleDetailsSet) { if (scheduleDetails.Time == curTime) { /* 如果当前行程是特定事件执行，但时间不对 */ if (scheduleDetails.day != 0 \u0026amp;\u0026amp; day == scheduleDetails.day) continue; if (scheduleDetails.season != season) continue; matchSchedule = scheduleDetails; } /* 排序是按照从小到大排序 */ else if (scheduleDetails.Time \u0026gt; curTime) { break; } } if (matchSchedule != null) { BuildPath(matchSchedule); } } NPC跨场景移动 使用一个专门的数据结构来保存跨场景时候的路径，以及跨场景的要使用的所有路径。然后在NPCManager中管理路径相关的信息，用单例模式的形式来保证NPC在移动的过程中能够正确的移动到目标位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [System.Serializable] public class SceneRoute { public string fromSceneName; public string gotoSceneName; public List\u0026lt;ScenePath\u0026gt; scenePathList; /*跨场景的多条路径*/ } [System.Serializable] public class ScenePath { public string sceneName; public Vector2Int fromGridCell; public Vector2Int gotoGridCell; } 在NPCManager中初始化路径相关的字典信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public SceneRouteDataList_SO sceneRouteDataListSo; public Dictionary\u0026lt;string, SceneRoute\u0026gt; SceneRouteDict = new Dictionary\u0026lt;string, SceneRoute\u0026gt;(); protected override void Awake() { base.Awake(); InitSceneRouteDict(); } private void InitSceneRouteDict() { if (sceneRouteDataListSo.sceneRouteList.Count \u0026gt; 0) { foreach (SceneRoute sceneRoute in sceneRouteDataListSo.sceneRouteList) { string key = sceneRoute.fromSceneName + sceneRoute.gotoSceneName; if (SceneRouteDict.ContainsKey(key)) continue; SceneRouteDict.Add(key, sceneRoute); } } } public SceneRoute GetSceneRoute(string fromSceneName, string gotoSceneName) { return SceneRouteDict[fromSceneName + gotoSceneName]; } 然后在NpcMovment中实现跨场景移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 else if (schedule.targetSceneName != currentScene) { /* 获得跨场景的路径 */ SceneRoute sceneRoute = NpcManager.Instance.GetSceneRoute(currentScene, schedule.targetSceneName); if (sceneRoute != null) { // 在设置数据的时候已经按照顺序保证场景移动，因此直接获取即可 for (int i = 0; i \u0026lt; sceneRoute.scenePathList.Count; i++) { var path = sceneRoute.scenePathList[i]; Vector2Int fromScenePos, gotoScenePos; if (path.fromGridCell.x \u0026gt; Settings.MaxCellLength || path.fromGridCell.y \u0026gt; Settings.MaxCellLength) { fromScenePos = (Vector2Int)_currentScenePos; } else { fromScenePos = path.fromGridCell; } if (path.gotoGridCell.x \u0026gt; Settings.MaxCellLength || path.gotoGridCell.y \u0026gt; Settings.MaxCellLength) { gotoScenePos = (Vector2Int)_targetScenePos; } else { gotoScenePos = path.gotoGridCell; } AStar.AStar.Instance.BuildPath(path.sceneName, fromScenePos, gotoScenePos, _movementSteps); } } } 注意NPC在移动过程中，每一步要走的格子都是通过栈的方式压入的，我们在构建NPC走过的路径的时候，也要注意保证要走过的路径是从后往前的。也就是说加载的顺序需要从终点往起点加载\n修改Astar代码的错误 在之前Astar代码中获得当前瓦片的位置处获得瓦片信息是从当前激活场景中获得信息\n1 string tileMapKey = mousePos.x + \u0026#34;x\u0026#34; + mousePos.y + \u0026#34;y\u0026#34; + SceneManager.GetActiveScene().name; 但是如果NPC跨越了场景，那么获得的瓦片信息还是当前场景的，就可以出现无法创建路径。因此需要对其进行修改\n1 2 3 // 获得当前瓦片的障碍信息 string key = tilePOS.x + \u0026#34;x\u0026#34; + tilePOS.y + \u0026#34;y\u0026#34; + sceneName; TileDetails curTile = GridMapManager.Instance.GetTileDetails(key); ","date":"2023-03-05T19:16:42+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E4%B9%9D/","title":"麦田物语开发日记(九)"},{"content":"种庄稼整体 种子库的构建 创建一个单独的代码来保存种子生长过程的全部信息CropDetails（种子的ID，不同阶段生成的天数int[]、生长的总天数、不同生长阶段的物品Prefab、不同阶段的图片、可种植的季节、收割工具信息、每种工具的使用次数、转换的新物品ID、收割果实的信息、收获的果实的数量、生成物体在地图上的范围、再次生长的时间、次数；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // CropDetails.cs [System.Serializable] public class CropDetails { [Header(\u0026#34;种子ID\u0026#34;)] public int seedItemId; [Header(\u0026#34;不同阶段的生长日期\u0026#34;)] public int[] growthDays; public int TotalGrowthDay { get { int amount = 0; foreach (var day in growthDays) { amount += day; } return amount; } } [Header(\u0026#34;不同阶段生长的Prefab\u0026#34;)] public GameObject[] growthObjects; [Header(\u0026#34;不同阶段生长图片\u0026#34;)] public Sprite[] growthSprites; [Header(\u0026#34;可种植的季节\u0026#34;)] public Season[] seasons; [Space] [Header(\u0026#34;可用于收获的工具\u0026#34;)] public int[] harvestToolItemID; [Header(\u0026#34;每种工具使用的次数\u0026#34;)] public int[] requireActionCount; [Header(\u0026#34;转化的新物品ID\u0026#34;)] public int transferItemId; [Space] [Header(\u0026#34;收获的果实信息\u0026#34;)] public int[] producedItemID; public int[] producedMinAmount; public int[] producedMaxAmount; [Header(\u0026#34;收获时物品在地图生成的范围\u0026#34;)] public Vector2 spawnRadius; [Header(\u0026#34;再次生长的时间\u0026#34;)] public int dayToRegrow; [Header(\u0026#34;再次生长的次数\u0026#34;)]public int regrowTimes; [Space] [Header(\u0026#34;Options\u0026#34;)] public bool generateAtPlayerPosition; public bool hasAnimation; public bool hasParticleEffect; //TODO:特效 音效 等 } 种植种子的逻辑 使用CropManager.cs来控制我们控制种子内容的种子库 然后设置使用种子的时候鼠标的效果 当鼠标携带种子点击地面的时候，点击事件需要传递相关内容到CropManager.cs中完成种子的种植 其中种子种植除了修改本身TileDetail的内容外，还要重新绘制地面信息等 为了实现控制种子库的内容需要先得到种子库的数据文件，然后当鼠标点击挖好的坑触发点击事件时，通过事件中心触发 种植逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 public class CropManager : MonoBehaviour { public CropDataList_SO cropDataListSo; private Transform _cropParent; private Grid _currentGrid; private Season _currentSeason; private void OnEnable() { EventHandler.PlantSeedEvent += OnPlantSeedEvent; EventHandler.AfterSceneLoadEvent += OnAfterSceneLoadEvent; EventHandler.GameDayEvent += OnGameDayEvent; } private void OnDisable() { EventHandler.PlantSeedEvent -= OnPlantSeedEvent; EventHandler.AfterSceneLoadEvent -= OnAfterSceneLoadEvent; EventHandler.GameDayEvent -= OnGameDayEvent; } #region 事件注册 private void OnPlantSeedEvent(ItemDetails itemDetails, TileDetails currentTile) { CropDetails currentCrop = GetCropDetails(itemDetails.itemID); /*存在该种子能够种植的内容，并且当前季节能够耕种*/ if (currentCrop != null \u0026amp;\u0026amp; IsValidSeason(currentCrop) \u0026amp;\u0026amp; currentTile.seedItemID == -1) { // 第一次种植 currentTile.seedItemID = itemDetails.itemID; currentTile.growthDays = 0; /*显示农作物*/ DisplayCropPlant(currentTile, currentCrop); }else if (currentTile.seedItemID != -1) // 用于刷新地图 { /**/ } } private void OnAfterSceneLoadEvent() { _currentGrid = FindObjectOfType\u0026lt;Grid\u0026gt;(); _cropParent = GameObject.FindWithTag(\u0026#34;CropParent\u0026#34;).transform; } private void OnGameDayEvent(int gameDay, Season season) { _currentSeason = season; } #endregion public CropDetails GetCropDetails(int seedID) { return cropDataListSo.cropDetailsList.Find(c =\u0026gt; c.seedItemId == seedID); } /// \u0026lt;summary\u0026gt; /// 检测当前所处季节是否能够播种的当前种子 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;cureDetails\u0026#34;\u0026gt;手持的种子\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private bool IsValidSeason(CropDetails cureDetails) { foreach (var validSeason in cureDetails.seasons) { if (_currentSeason == validSeason) return true; } return false; } /// \u0026lt;summary\u0026gt; /// 种植种子后显示种子样式 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentTail\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;currentCrop\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void DisplayCropPlant(TileDetails currentTail, CropDetails currentCrop) { int growthStages = currentCrop.growthObjects.Length; int currentStage = 0; int dayCount = currentCrop.TotalGrowthDay; /*从后往前获取当前种子应该所处的生长阶段*/ for (int i = growthStages - 1; i \u0026gt;= 0; i--) { if (currentTail.growthDays \u0026gt;= dayCount) { currentStage = i; break; } else { dayCount -= currentCrop.growthDays[i]; } } /*在对应位置生成对应的item*/ Vector3 cropPos = new Vector3(currentTail.gridPos.x + 0.5f, currentTail.gridPos.y + 0.5f, 0); GameObject cropPrefab = currentCrop.growthObjects[currentStage]; var cropInstance = Instantiate(cropPrefab, cropPos, Quaternion.identity, _cropParent); cropInstance.GetComponentInChildren\u0026lt;SpriteRenderer\u0026gt;().sprite = currentCrop.growthSprites[currentStage]; } } 种子的成长 为了让种子每个阶段的GO能够正常显示，且和原本的ItemBase不发生冲突，因此需要新建一个Prefab\n由于拥有了Crop代码，刷新所有的种子只需要通过FindObjectsOfType\u0026lt;\u0026gt;找到所有的植物GO，然后逐个销毁，再重建即可。\n因此需要修改重绘地图的代码\n1 2 3 4 5 6 // 在GridManager.cs 的RefreshGridMap()方法中销毁种子图片实例 Crop[] totalCrop = FindObjectsOfType\u0026lt;Crop\u0026gt;(); foreach (Crop crop in totalCrop) { Destroy(crop.gameObject); } 然后再和其他瓦片信息一起重建\n1 2 3 // 在GridManager.cs 的DisplayMap()方法中重新种植种子 if (tileMapDic.Value.seedItemID != -1) EventHandler.CallPlantSeedEvent(currentTile.seedItemID, currentTile); 根据日期更改来修改整个tileDetails中种子种植的信息\n1 2 3 4 5 6 7 // 在GridManager.cs 的OnGameDayEvent中修改当前tile的信息 // 同时保证在昨天浇了水的情况下植物才能生长 bool tileWateredYesterday = tileDic.Value.daySinceWater \u0026gt; -1; if (tileDic.Value.seedItemID != -1 \u0026amp;\u0026amp; tileWateredYesterday) { tileDic.Value.growthDays++; } 种子种下后修改当前人物背包中（由于有一个事件是丢弃人物背包中的内容，因此我们修改当前事件的部分条件，实现如果是种子则不生成物品即可。 1 2 3 4 5 6 7 // 在itemManager.cs中实现该方法 private void OnDropItemInSceneEvent(int itemId, Vector3 mousePos, ItemType itemType) { // 实现丢东西后在对应位置生成物体功能 if (itemType == ItemType.Seed) return; // 如果种下种子，则不表示丢弃 ..... } 使用菜篮子收菜 整体思路与普通的切动画，完成点击事件一样，仅仅在收获的时候，需要使用碰撞检测，鼠标点击后检测到了碰撞，才能表示点击到了需要收获的物品。\n点击事件 由于点击需要判断当前的种子是否长成熟，因此要将CropManager.cs修改为单例模式来获取种子信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Cursor.cs的 CheckCursorValid()方法 case ItemType.CollectTool: CropDetails currentCrop = CropManager.Instance.GetCropDetails(currentTile.seedItemID); if (currentCrop != null) { if (currentTile.growthDays \u0026gt;= currentCrop.TotalGrowthDay) SetCursorValid(); else SetCursorInvalid(); } else SetCursorInvalid(); break; 然后将动画修改为pull相关动画\n使用Unity自带的碰撞体检测，OverlapPointAll()方法，该方法传递一个鼠标坐标，然后范围该坐标下的所有碰撞体，通过检测这些碰撞体是否有Crop元素即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 在GridMapManager.cs的执行事件方法中调用 case ItemType.CollectTool: Crop currentCrop = GetCropObject(mouseGridPos); if (currentCrop != null) Debug.Log(currentCrop); break; private Crop GetCropObject(Vector3 mousePos) { Collider2D[] collider2Ds = Physics2D.OverlapPointAll(mousePos); Crop currentCrop = null; foreach (var col in collider2Ds) { if (col.GetComponent\u0026lt;Crop\u0026gt;()) { currentCrop = col.GetComponent\u0026lt;Crop\u0026gt;(); break; } } return currentCrop; } 实现收割庄稼产生果实 由于不同植物需要收获的次数不同，因此需要传递采集次数给Crop来判断是否能够完成收割。\n首先我们也要在CursorManager中判断当前选择的采集物品是否和当前采集的植物匹配，而匹配的方法将使用工具的ID和采集植物的工具ID是否匹配的方式进行判断，因此直接在CropDetails中进行修改\n然后我们需要完成采集工作，即在gridManager中调用Crop中包含的采集方法ProcessToolAction，该方法检查当前采集次数是否满足，不满足则要求继续执行，满足则将采集的物品数量和ID通过事件的方式传递给InventoryManager，存入人物的背包中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /// \u0026lt;summary\u0026gt; /// 检查当前使用的收割工具是否满足当前物品的要求 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;toolID\u0026#34;\u0026gt;当前的工具Id\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool CheckToolAvailable(int toolID) { foreach (int harvestToolID in harvestToolItemIDs) { if (harvestToolID == toolID) return true; } return false; } /// \u0026lt;summary\u0026gt; /// 检测当前工具需要收获的次数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;toolID\u0026#34;\u0026gt;当前的工具Id\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int GetTotalRequireCount(int toolID) { for (int i = 0; i \u0026lt; harvestToolItemIDs.Length; i++) { if (harvestToolItemIDs[i] == toolID) { return requireActionCounts[i]; } } return -1; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public CropDetails currentCropDetails; private int _currentHarvestCnt; /// \u0026lt;summary\u0026gt; /// 完成工具处理植物的具体内容 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;itemID\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void ProcessToolAction(int itemID, TileDetails tileDetails) { int requireHarvestCnt = currentCropDetails.GetTotalRequireCount(itemID); if (requireHarvestCnt == -1) return; if (++_currentHarvestCnt \u0026lt; requireHarvestCnt) { _currentHarvestCnt++; // todo 音效 粒子效果 } else { /*判断当前的农作物是否是树（是否在人物头顶生成*/ if (currentCropDetails.generateAtPlayerPosition) { // 真实生成物品 SpawnHarvestItem(); } } } public void SpawnHarvestItem() { for (int i = 0; i \u0026lt; currentCropDetails.producedItemIDs.Length; i++) { int produceCnt = currentCropDetails.producedMinAmount[i] == currentCropDetails.producedMaxAmount[i] ? currentCropDetails.producedMinAmount[i] : Random.Range(currentCropDetails.producedMinAmount[i], currentCropDetails.producedMaxAmount[i] + 1); /* 生成对应数量的物品 */ if (currentCropDetails.generateAtPlayerPosition) { EventHandler.CallHarvestAtPlayerPosEvent(currentCropDetails.producedItemIDs[i], produceCnt); } } } // inventoryManager.cs中完成 private void OnHarvestAtPlayerPosEvent(int produceID, int produceAmount) { var indexIndex = GetItemIndexInBag(produceID); if (AddItemInIndex(produceID, indexIndex, produceAmount)) { // 更新UI EventHandler.CallUpdateInventoryUI(InventoryLocation.Player, playerBag.inventoryItemList); } } 实现农作物收割后的销毁或重新生成 实现农作物收割后的情况处理，需要在人物收获到农作物以后对当前作物的特性进行判别，如果是可以重新生长的则将其生长日期减少，直到重生次数用尽，否则就直接销毁。\n判断能否重新生长需要看作物的属性以及当前生长的次数，因此需要从当前TileDetails中获得部分信息。此时如果不重新生成，则将地图信息中的种子重置为-1，然后使用事件通知的方式重新刷新地图\n当前瓦片的信息可以通过调用Crop ProcessToolAction方法获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Crop.cs 的SpawnHarvestItem() { /*判断当前作物的是否能够重新生长，其生长次数是否达标*/ if (currentCropDetails.dayToRegrow \u0026gt; -1 \u0026amp;\u0026amp; ++_currentTileDetails.reHarvestCnt \u0026lt;= currentCropDetails.regrowTimes) { _currentTileDetails.growthDays = currentCropDetails.TotalGrowthDay - currentCropDetails.dayToRegrow; // 刷新种子 EventHandler.CallRefreshCurrentMapEvent(); } else { _currentTileDetails.daySinceHarvest = -1; _currentTileDetails.seedItemID = -1; _currentTileDetails.daySinceDig = 0; } if (gameObject !=null) Destroy(gameObject); } 制作可砍伐的木头摇晃和倒下的动画 基础设计思路和制作普通的农作物一致，只是最后一个阶段的预制体需要替换为我们预先设计好的可砍伐的树木的预制体。然后需要保证该树有我们定好的Crop脚本。\n然后制作对应的动画，由于收集逻辑和砍树逻辑在鼠标的可执行阶段是类似的，因此可以将两个case合并。\n在GridManager.cs中采集主要的方法是ProcessToolAction，可以在该处判断当前的物体需要砍伐的次数，以及生成物品的位置。\n在该过程中可以通过点击事件获取当前物体的物体的动画组件，然后执行被砍伐的时候的动画\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Crop.cs 的ProcessToolAction if (++_currentHarvestCnt \u0026lt; requireHarvestCnt) { _currentHarvestCnt++; // todo 音效 粒子效果 if (_animator != null \u0026amp;\u0026amp; currentCropDetails.hasAnimation) { /*判断人物和物品的位置，判断该从那边伐木*/ if (Player.position.x \u0026lt; transform.position.x) { // 树木向右被砍的动画 _animator.SetTrigger(\u0026#34;RotateRight\u0026#34;); } else { _animator.SetTrigger(\u0026#34;RotateLeft\u0026#34;); } } } 摇晃动画\n实现砍树功能 由于鼠标的有效性检测检测的是瓦片格，但实际树木应该能够点按树干，因此需要对整个内容进行修改，因此需要再使用ChopTool的时候，判断当前鼠标和gridMap是否有作物成熟，但由于树干整体偏大，因此当鼠标移动到目标位置时，应该直接判断当前作物是否成熟，因此当植物成熟的时候，就可以为其添加一个标致，使得其能够被鼠标识别，同时在将对应的瓦片地图信息传递给ProcessToolAction方法时，传递的应该时当前作物的瓦片，而不是当前地图块的瓦片，因此在成熟生成prefab的时候，就应该传递当前作物的成熟信息。\nCursorManager 增加对树干的识别，currentCrop需要通过鼠标的坐标去获取 1 2 3 4 5 6 7 8 9 10 // CursorManager Crop currentCrop = GridMapManager.Instance.GetCropObject(_mouseWorldPos); case ItemType.ChopTool: if (currentCrop != null \u0026amp;\u0026amp; currentCrop.CanHarvest) SetCursorValid(); else SetCursorInvalid(); break; GridMapManager 此时ProcessToolAction不应该传递鼠标所在位置的tileDetails，应该是物体的信息 1 2 3 4 5 case ItemType.ChopTool: currentCrop = GetCropObject(mouseWorldPos); if (currentCrop != null) currentCrop.ProcessToolAction(itemDetails.itemID, currentCrop.currentTileDetails); break; CropManger，增加成熟后直接获取当前地图块信息，保存作物能够直接知道自己是否成熟 1 cropInstance.GetComponent\u0026lt;Crop\u0026gt;().currentTileDetails = currentTail; Crop.cs，添加变量CanHarvest，让鼠标能得到信息 1 public bool CanHarvest =\u0026gt; currentTileDetails.growthDays \u0026gt;= currentCropDetails.TotalGrowthDay; 修改相应动画\n注意动画需要在对应载体上才能进行操作,同时添加关键帧的操作需要先点击录制.\n注意动画迁移是否需要上一个状态完整播放（是否有退出时间）\n实现随机数生成收割物品 由于树木倒下有时间，因此需要有一点时间，因此需要使用协程的方式循环检测当前的动画是否播放到树木倒下结束。当树木倒下的时候，生成物品。\n由于生成物品是在地面上，因此需要先得知物体倒下的位置，并获得一个掉落位置的随机值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private IEnumerator HarvestAfterAnimation() { while (!_animator.GetCurrentAnimatorStateInfo(0).IsName(\u0026#34;END\u0026#34;)) { yield return null; } SpawnHarvestItem(); /* 生成遗留物品 */ currentTileDetails.seedItemID = currentCropDetails.transferItemId; currentTileDetails.growthDays = 0; currentTileDetails.daySinceHarvest = 0; EventHandler.CallRefreshCurrentMapEvent(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Crop.cs中的 ProcessToolAction if (++_currentHarvestCnt \u0026lt; requireHarvestCnt) { _currentHarvestCnt++; // todo 音效 粒子效果 if (_animator != null \u0026amp;\u0026amp; currentCropDetails.hasAnimation) { /*判断人物和物品的位置，判断该从那边伐木*/ if (Player.position.x \u0026lt; transform.position.x) { // 树木向右被砍的动画 _animator.SetTrigger(\u0026#34;RotateRight\u0026#34;); } else { _animator.SetTrigger(\u0026#34;RotateLeft\u0026#34;); } } } else { /*判断当前的农作物是否是树（是否在人物头顶生成*/ if (currentCropDetails.generateAtPlayerPosition || !currentCropDetails.hasAnimation) { // 真实生成物品 SpawnHarvestItem(); } else { if (Player.position.x \u0026lt; transform.position.x) { // 树木向右被砍的动画 _animator.SetTrigger(\u0026#34;FallRight\u0026#34;); } else { _animator.SetTrigger(\u0026#34;FallLeft\u0026#34;); } StartCoroutine(HarvestAfterAnimation()); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Crop.cs 中生成果实的方法 /* 生成对应数量的物品 */ if (currentCropDetails.generateAtPlayerPosition) { EventHandler.CallHarvestAtPlayerPosEvent(currentCropDetails.producedItemIDs[i], produceCnt); } else { // 世界地图上生成物品 int dirx = transform.position.x - Player.position.x \u0026gt; 0 ? 1 : -1; /* 农作物和人物的相对位置 */ for (int j = 0; j \u0026lt; produceCnt; j++) { float randomXPos = transform.position.x + Random.Range(dirx, dirx + currentCropDetails.spawnRadius.x * dirx); float randomYPos = transform.position.y + Random.Range(-currentCropDetails.spawnRadius.y, currentCropDetails.spawnRadius.y); Vector3 spawnPos = new Vector3(randomXPos, randomYPos, 0); EventHandler.CallInstantiateBounceItemInScene(currentCropDetails.producedItemIDs[i], transform.position + new Vector3(dirx * 1.4f, 0, 0), spawnPos); } } 实现快捷键 为SlotUI增加按键方法，然后调用InventoryUI中的控制高亮的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [RequireComponent(typeof(SlotUI))] public class ActionBarButton : MonoBehaviour { public KeyCode key; private SlotUI _slotUI; private void Start() { _slotUI = GetComponent\u0026lt;SlotUI\u0026gt;(); } // Update is called once per frame void Update() { if (Input.GetKeyDown(key)) { if (_slotUI != null \u0026amp;\u0026amp; _slotUI.slotItemDetails != null) { _slotUI.isSelected = !_slotUI.isSelected; if (_slotUI.isSelected) { _slotUI.InventoryUI.UpdateSlotHighlight(_slotUI.slotIndex); } else { _slotUI.InventoryUI.UpdateSlotHighlight(-1); } EventHandler.CallItemSelectedEvent(_slotUI.slotItemDetails, _slotUI.isSelected); } } } } 粒子系统 在场景中增加例子效果，并将其作为一个预制体，为后续用对象池完成粒子生成做准备。因此首先需要设计粒子的类型\n1 2 3 4 public enum ParticleEffectType { None, LeavesFalling01,LeavesFalling02, Rock, ReapableScenery } 使用对象池创建粒子效果 通过对象池来完成粒子效果的创建，能够不用我们手动一直创建并销毁由对象池生成的GO，其有三个主要方法，Get,Relese，Destroy，其中如果对象池如果有内容，则Get会直接获得对象池里的内容。\n在本部分使用Get来是粒子效果Active,Relese让效果Active失效，这样如果需要新的粒子，对象池会先去找对象池内的GO，让其Active\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class PoolManager : MonoBehaviour { public List\u0026lt;GameObject\u0026gt; prefabList; private Dictionary\u0026lt;string, ObjectPool\u0026lt;GameObject\u0026gt;\u0026gt; _poolEffectDic = new Dictionary\u0026lt;string, ObjectPool\u0026lt;GameObject\u0026gt;\u0026gt;(); private void OnEnable() { EventHandler.EffectEvent += OnEffectEvent; } private void OnDisable() { EventHandler.EffectEvent -= OnEffectEvent; } private void Start() { CreatPool(); } private void CreatPool() { if (prefabList == null) return; foreach (GameObject prefabItem in prefabList) { string key = prefabItem.name; GameObject parent = new GameObject(key); parent.transform.SetParent(transform); // 让所有粒子效果都属于自己对应的名称下，每个名称属于PoolManager下 if (!_poolEffectDic.ContainsKey(key)) { _poolEffectDic.Add(key, new ObjectPool\u0026lt;GameObject\u0026gt;( () =\u0026gt; Instantiate(prefabItem, parent.transform), e =\u0026gt; {e.SetActive(true);}, e=\u0026gt;{e.SetActive(false);}, e =\u0026gt; {Destroy(e);})); } } } private void OnEffectEvent(ParticleEffectType effectType, Vector3 effectPos) { Debug.Log(effectType.ToString()); if (_poolEffectDic.ContainsKey(effectType.ToString())) { ObjectPool\u0026lt;GameObject\u0026gt; effectPool = _poolEffectDic[effectType.ToString()]; GameObject effect = effectPool.Get(); effect.transform.position = effectPos; /*延迟关闭*/ StartCoroutine(ReleaseRoutine(effectPool, effect)); } } private IEnumerator ReleaseRoutine(ObjectPool\u0026lt;GameObject\u0026gt; effectPool, GameObject effect) { yield return new WaitForSeconds(1.5f); effectPool.Release(effect); } } 然后通过事件调用即可\n预生产树木 由于所有的农作物都是需要保证地块有种子信息，否则会在场景加载的时候被销毁。因此对于需要预制的植物，需要为其的地块设定种子信息。\n因此新增一个脚本CropGenerator.cs，该脚本用于对当前瓦片信息进行赋值，并更新瓦片地图dictionary的内容。最后保证只有在首次加载地图的时候才生成。\n注意此时CropGenerator.cs的生成代码是需要先给tileMapDic增加新的值，才能保证刷新地图的时候预制的物体被销毁后能够重新绘制\n但是由于不同脚本的执行顺序不能确定，因此需要在刷新之前先将赋值完成，因此需要在每次加载场景的时候先保证预制物品能够修改tileMapDic的内容，并保证只有第一次加载场景，才为树木增加预制体，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class CropGenerator : MonoBehaviour { [Header(\u0026#34;作物信息\u0026#34;)] public int seedId; public int growthDays; private Grid _currentGrid; private void OnEnable() { EventHandler.GenerateCropEvent += GenerateItem; } private void OnDisable() { EventHandler.GenerateCropEvent -= GenerateItem; } private void Awake() { _currentGrid = FindObjectOfType\u0026lt;Grid\u0026gt;(); } public void GenerateItem() { Vector3Int curGridPos = _currentGrid.WorldToCell(transform.position); if (seedId != 0) { TileDetails currentTileDetails = GridMapManager.Instance.GetTileDetailsByMousePos(curGridPos); if (currentTileDetails == null) { currentTileDetails = new TileDetails(); } currentTileDetails.daySinceWater = -1; currentTileDetails.growthDays = growthDays; currentTileDetails.seedItemID = seedId; currentTileDetails.gridPos = new Vector2Int(curGridPos.x, curGridPos.y); GridMapManager.Instance.UpdateGridMap(currentTileDetails); } } } 1 2 3 4 5 6 7 8 // OnAfterSceneLoadEvent() /*只有初次加载地图的时候生成预制树木*/ if (_firstLoadDic.ContainsKey(SceneManager.GetActiveScene().name) \u0026amp;\u0026amp; _firstLoadDic[SceneManager.GetActiveScene().name]) { EventHandler.CallGenerateCropEvent(); _firstLoadDic[SceneManager.GetActiveScene().name] = false; } RefreshGridMap(); 制作割草的全部流程和稻草互动摇晃 当杂草过多的时候，一个一个检查杂草的碰撞体然后收割效率太低，因此 使用额外的方法来完成收割大量杂草的方法.\n首先需要将杂草设定为item而不是Crop因此需要一个额外的脚本ReapItem来控制割草事件。该脚本需要获得cropDetails的信息，因此在item初始化的时候就要为其赋值，然后再ReapItem中调用收割方法，产生种子。\n而检测是否是杂草的方法需要在CursorManager中进行调用，在GridMapManager中使用函数获得相应的内容，然后再CursorManager中调用该方法，最后在GridMapManager触发事件。\nReapItem 该部分用于实现可割除草的初始化，以及果实的产生\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 private CropDetails _currentCropDetail; private Transform Player =\u0026gt; FindObjectOfType\u0026lt;Player\u0026gt;().transform; public void InitReapItem(int cropID) { _currentCropDetail = CropManager.Instance.GetCropDetails(cropID); } /*生成果实*/ public void SpawnHarvestItem() { for (int i = 0; i \u0026lt; _currentCropDetail.producedItemIDs.Length; i++) { int produceCnt = _currentCropDetail.producedMinAmount[i] == _currentCropDetail.producedMaxAmount[i] ? _currentCropDetail.producedMinAmount[i] : Random.Range(_currentCropDetail.producedMinAmount[i], _currentCropDetail.producedMaxAmount[i] + 1); /* 生成对应数量的物品 */ if (_currentCropDetail.generateAtPlayerPosition) { EventHandler.CallHarvestAtPlayerPosEvent(_currentCropDetail.producedItemIDs[i], produceCnt); } else { // 世界地图上生成物品 int dirx = transform.position.x - Player.position.x \u0026gt; 0 ? 1 : -1; /* 农作物和人物的相对位置 */ for (int j = 0; j \u0026lt; produceCnt; j++) { float randomXPos = transform.position.x + Random.Range(dirx, dirx + _currentCropDetail.spawnRadius.x * dirx); float randomYPos = transform.position.y + Random.Range(-_currentCropDetail.spawnRadius.y, _currentCropDetail.spawnRadius.y); Vector3 spawnPos = new Vector3(randomXPos, randomYPos, 0); EventHandler.CallInstantiateBounceItemInScene(_currentCropDetail.producedItemIDs[i], transform.position + new Vector3(dirx * 1.4f, 0, 0), spawnPos); } } } } item.cs 该部分用于在初始化物品的时候对，就对可割除的草进行初始化\n1 2 3 4 5 if (itemDetails.itemType == ItemType.ReapableScenery) { gameObject.AddComponent\u0026lt;ReapItem\u0026gt;(); gameObject.GetComponent\u0026lt;ReapItem\u0026gt;().InitReapItem(itemID); } GridMapManager.cs 在该部分，用于具体的执行收割和果实生产的内容，因此需要先获得所有可收割的内容，使用碰撞检测器的一个特殊方法，找出鼠标范围内的所有可收割的部分\n1 Physics2D.OverlapCircleNonAlloc(mousePos, toolDetail.itemUseRadius, colliders); 然后将所有检测到有可收割部分的内容添加到一个列表中，当点击割除事件的时候，遍历这些内容，然后进行销毁并产生果实。\n注意由于鼠标要可用的时候才能执行点击方法，因此该部分需要有一个方法能够返回当前是否检测到了可收割内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 检测是否可以收割 public bool HaveReapableItemInRadius(Vector3 mousePos, ItemDetails toolDetail) { /*实时检测鼠标周围是否有杂草*/ _reapItemInRadius = new List\u0026lt;ReapItem\u0026gt;(); Collider2D[] colliders = new Collider2D[20]; // 接受检测到碰撞的内容 Physics2D.OverlapCircleNonAlloc(mousePos, toolDetail.itemUseRadius, colliders); if (colliders.Length \u0026gt; 0) { foreach (var col in colliders) { if (col is not null \u0026amp;\u0026amp;col.GetComponent\u0026lt;ReapItem\u0026gt;()) { _reapItemInRadius.Add(col.GetComponent\u0026lt;ReapItem\u0026gt;()); } } } return _reapItemInRadius.Count \u0026gt; 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 执行收割事件 case ItemType.ReapTool: /* 循环将被检测到的杂草一一清除，并生成对应果实 */ for (int i = 0; i \u0026lt; _reapItemInRadius.Count; i++) { EventHandler.CallEffectEvent(ParticleEffectType.ReapableScenery, _reapItemInRadius[i].transform.position + Vector3.up); _reapItemInRadius[i].SpawnHarvestItem(); Destroy(_reapItemInRadius[i].gameObject); // 由于鼠标检测的内容是实时生成的，因此每次列表都会刷新 if (i \u0026gt; Settings.ReapLimit) { break; } } break; CursorManager 当鼠标检测到可以收割的时候，就允许触发相应事件。\n1 2 3 4 case ItemType.ReapTool: if (GridMapManager.Instance.HaveReapableItemInRadius(_mouseWorldPos, _currentItem)) SetCursorValid(); else SetCursorInvalid(); break; 实现摇晃功能 使用代码完成该功能，当有碰撞体的东西i经过的时候，使用协程完成物体sprite的摇晃\n因此需要摇晃的物体需要挂载一个新的脚本\nitem 1 2 3 4 5 6 7 8 if (itemDetails.itemType == ItemType.ReapableScenery) { gameObject.AddComponent\u0026lt;ReapItem\u0026gt;(); gameObject.GetComponent\u0026lt;ReapItem\u0026gt;().InitReapItem(itemID); gameObject.AddComponent\u0026lt;ItemInteractive\u0026gt;(); gameObject.GetComponent\u0026lt;BoxCollider2D\u0026gt;().isTrigger = true; _boxCollider2D.size *= 0.5f; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class ItemInteractive : MonoBehaviour { private bool _isAnimation = false; private WaitForSeconds _pauseSeconds = new WaitForSeconds(0.04f); private void OnTriggerEnter2D(Collider2D col) { if (!_isAnimation) { if (col.transform.position.x \u0026gt; transform.position.x) { StartCoroutine(RotateLeft()); } else { StartCoroutine(RotateRight()); } } } private void OnTriggerExit2D(Collider2D other) { if (!_isAnimation) { if (other.transform.position.x \u0026gt; transform.position.x) { StartCoroutine(RotateRight()); } else { StartCoroutine(RotateLeft()); } } } private IEnumerator RotateLeft() { _isAnimation = true; for (int i = 0; i \u0026lt; 4; i++) { transform.GetChild(0).Rotate(0,0,2); // 延Z轴摇晃两度 yield return _pauseSeconds; } for (int i = 0; i \u0026lt; 5; i++) { transform.GetChild(0).Rotate(0,0,-2); // 延Z轴摇晃两度 yield return _pauseSeconds; } transform.GetChild(0).Rotate(0,0,2); // 延Z轴摇晃两度 yield return _pauseSeconds; _isAnimation = false; } private IEnumerator RotateRight() { _isAnimation = true; for (int i = 0; i \u0026lt; 4; i++) { transform.GetChild(0).Rotate(0,0,-2); // 延Z轴摇晃两度 yield return _pauseSeconds; } for (int i = 0; i \u0026lt; 5; i++) { transform.GetChild(0).Rotate(0,0,2); // 延Z轴摇晃两度 yield return _pauseSeconds; } transform.GetChild(0).Rotate(0,0,-2); // 延Z轴摇晃两度 yield return _pauseSeconds; _isAnimation = false; } } ","date":"2023-03-05T19:16:40+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%85%AB/","title":"麦田物语开发日记(八)"},{"content":"游戏内容 鼠标图标的变化 使用一个图片来跟随鼠标移动，用该方式来表示鼠标的变化\n由于是跨场景赋值，Manager是主场景，而UI是另一个场景，因此不能直接用层次窗口拖拽的方式，需要通过tag去查找我们的canvas的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class CursorManager : MonoBehaviour { public Sprite normal, tool, seed, item; private Sprite _currentSprite; // 临时承接下一帧应该使用的图标 private Image _cursorImage; // 实际的图标的图片 private RectTransform _cursorCanvas; // 通过代码获得画布的内容 private void Start() { /*跨场景获取鼠标图片的信息*/ _cursorCanvas = GameObject.FindGameObjectWithTag(\u0026#34;CursorCanvas\u0026#34;).GetComponent\u0026lt;RectTransform\u0026gt;(); _cursorImage = _cursorCanvas.GetChild(0).GetComponent\u0026lt;Image\u0026gt;(); _currentSprite = normal; } // 当快捷栏的物品被选取时，鼠标图案会相应更改 private void OnEnable() { EventHandler.ItemSelectedEvent += OnItemSelectCursorImage; } private void OnDisable() { EventHandler.ItemSelectedEvent -= OnItemSelectCursorImage; } private void Update() { if (_cursorCanvas == null) return; _cursorImage.transform.position = Input.mousePosition; /* 只有当鼠标与非UI互动时才修改鼠标样式 */ if (!InteractWithUI()) { SetCursorImage(_currentSprite); } else { SetCursorImage(normal); } } private void SetCursorImage(Sprite cursorSprite) { _cursorImage.sprite = cursorSprite; _cursorImage.color = new Color(1, 1, 1, 1); //保证原色 } private void OnItemSelectCursorImage(ItemDetails itemDetail, bool isSelected) { /*将临时图标修改为当前选取的物品类型对应的图标*/ if (isSelected) { _currentSprite = itemDetail.itemType switch { ItemType.Seed =\u0026gt; seed, ItemType.Commodity =\u0026gt; item, ItemType.ChopTool =\u0026gt; tool, ItemType.HoeTool =\u0026gt; tool, ItemType.WaterTool =\u0026gt; tool, ItemType.BreakTool =\u0026gt; tool, ItemType.ReapTool =\u0026gt; tool, ItemType.Furniture =\u0026gt; tool, _ =\u0026gt; normal }; } else { _currentSprite = normal; } } /// \u0026lt;summary\u0026gt; /// 当前鼠标是否在与UI互动 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private bool InteractWithUI() { /*通过当前UI的事件系统判断, 如果指针覆盖于UI的go上，鼠标为默认央视*/ if (EventSystem.current != null \u0026amp;\u0026amp; EventSystem.current.IsPointerOverGameObject()) { return true; } else { return false; } } } 设置瓦片地图的地图事件 方案1：设置每一个瓦片继承自一个tileGO类似ruleTile的形式，然后这个GO有什么属性，瓦片地图就会有什么属性（缺点：每个瓦爿都需要内容，瓦片过多时影响性能）\n方案2：使用Unity提供的2D extra中的grid information组件来解决，该组件代码能够为对应位置的瓦片设置对应的属性（int, float等，没有bool）。（问题同上）\n方案3：编写一个事件系统，能够让我们以绘制collision类似的方式去绘制信息，然后通过代码自动拿到绘制的信息存储到SO文件中，然后通过专门的代码去处理这些信息。\n**思路：**首先需要设置每个Tile应该有的具体信息（坐标，事件类型，以及事件是否能被执行的变量），然后制作一个SO文件，为每个地图指定SO文件应该包含的的内容。\n最后设计一个代码，该代码能够在tilemap的绘制完成后，将绘制的信息保存到SO文件中，即当我们手动关闭Grid Propertie的子物体的时候，进行保存。\n特殊函数\n1 2 3 Application.IsActive(this);\t//是否在运行 tileMap.cellBounds;\t// 压缩地图，获得当前GO下绘制的tileMap内容 tileMap.cellBounds.min, max;\t// 获得压缩后地图的左下角和右上角坐标 设计每个瓦片应该含有的信息 1 2 3 4 5 6 7 8 9 10 11 12 [System.Serializable] public class TileProperties { public Vector2Int tileCoordinate; /*网格的坐标*/ public GridType gridType; /*该网格的具体类型*/ public bool boolTypeValue; /*该类型是否可用*/ } public enum GridType { Diggable, DropItem, PlaceFurniture, NpcObstacle } 构建SO文件 1 2 3 4 5 6 7 // MapData_SO.cs [CreateAssetMenu(fileName = \u0026#34;MapData_SO\u0026#34;, menuName = \u0026#34;Map/MapData\u0026#34;)] public class MapData_SO : ScriptableObject { [SceneName]public string sceneName; public List\u0026lt;TileProperties\u0026gt; tileProperties; } 设计自动将绘制信息读取到SO文件的代码 由于该部分内容是在编辑窗口运行的代码，在实际运行中不能直接执行，因此需要在该代码前写[ExecuteInEditMode]\n并且设置该部分代码需要在GO关闭的时候运行，因此需要在代码的OnEnable和OnDisable部分处理\n在SO文件中，每次修改后，如果不直接保存，则下一次打开会直接丢失数据，因此需要在代码中设置EditorUtility.SetDirty(mapDataSo);来保存加载好的So文件\n该图片为压缩图片后的到的数据信息\n注意该代码需要每一个Property的GO都挂载，并加载内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 using System; using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; using UnityEngine.Tilemaps; [ExecuteInEditMode] public class GridMap : MonoBehaviour { /*设置当挂载该脚本的瓦片GO关闭时，将该GO下的所有有信息的瓦片全部存储在对应的GO中*/ public MapData_SO mapDataSo; /*存储的So文件*/ public GridType gridType; /*当前GO对应的类型*/ private Tilemap _currentTilemap; /*由于是在GO开启和关闭的时候绘制，因此需要使用OnEnable和 OnDisable*/ private void OnEnable() { /*只有当程序没有运行的时候，才能执行此处的代码*/ if (!Application.IsPlaying(this)) { _currentTilemap = GetComponent\u0026lt;Tilemap\u0026gt;(); /*为了便于不断的绘制，因此设计，开启GO就重新绘制，关闭GO就存储*/ if (mapDataSo != null) { mapDataSo.tileProperties.Clear(); } } } /*关闭后存储绘制的内容*/ private void OnDisable() { /*只有当程序没有运行的时候，才能执行此处的代码*/ if (!Application.IsPlaying(this)) { _currentTilemap = GetComponent\u0026lt;Tilemap\u0026gt;(); /*从整个界面中，遍历所有以及绘制了的瓦片，然后将其内容存储进入SO文件中*/ UpdateTileProperties(); /*只有当在编辑窗口的时候，才能保存数据*/ #if UNITY_EDITOR if (mapDataSo != null) { EditorUtility.SetDirty(mapDataSo); } #endif } } /// \u0026lt;summary\u0026gt; /// 将所有绘制内容存储进入SO中 /// \u0026lt;/summary\u0026gt; private void UpdateTileProperties() { _currentTilemap.CompressBounds(); /*压缩范围，获取当前绘制瓦片的左下角和右上角返回*/ if (!Application.IsPlaying(this)) { if (mapDataSo != null) { /*议会制范围可能有空*/ /*已绘制范围的左下角位置*/ Vector3Int startPos = _currentTilemap.cellBounds.min; /*已绘制范围的右上角位置*/ Vector3Int endPos = _currentTilemap.cellBounds.max; for (int x = startPos.x; x \u0026lt; endPos.x; x++) { for (int y = startPos.y; y \u0026lt; endPos.y; y++) { /*获得当前坐标下瓦片的的内容*/ TileBase tile = _currentTilemap.GetTile(new Vector3Int(x, y, 0)); /*如果该位置是绘制了内容的*/ if (tile != null) { TileProperties newTile = new TileProperties { tileCoordinate = new Vector2Int(x, y), gridType = this.gridType, boolTypeValue = true }; mapDataSo.tileProperties.Add(newTile); } } } } } } } 生成地图信息 创建一个管理类，用于管理地图信息，方便后续的内容获得地图信息。\n思路： 首先需要创建一个管理该瓦片所有信息的类，包含所有在tileMapData中存储的某一种Property的属性，以及未来可能会使用的信息(是否被挖掘，是否被浇水，种了什么种子，已经长了多少天，上一次收割后隔了多少天)\n然后对整个mapdata进行遍历，将里面存放的内容初始化好后，全部读取进入一个字典中。\n为了鼠标能够对这些地图信息进行识别地图信息，因此需要先设置在CursorManager中设置好地图的整体信息，然后让鼠标能够正常获取这些坐标信息，一边后续将鼠标信息和字典的信息进行比对\n管理mapData信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class GridMapManager : MonoBehaviour { public List\u0026lt;MapData_SO\u0026gt; mapDataSos; private Dictionary\u0026lt;string, TileDetails\u0026gt; _tileDetailsMap = new Dictionary\u0026lt;string, TileDetails\u0026gt;(); /*获得所有瓦片的具体信息*/ /*初始化所有瓦片的信息*/ private void Start() { foreach (MapData_SO mapData in mapDataSos) { InitTileDetailsMap(mapData); } } private void InitTileDetailsMap(MapData_SO mapDataSo) { if (mapDataSo.tileProperties != null) { foreach (TileProperties tileProperty in mapDataSo.tileProperties) { int tileX = tileProperty.tileCoordinate.x; int tileY = tileProperty.tileCoordinate.y; string tileDetailKey = tileX + \u0026#39;x\u0026#39; + tileY + \u0026#39;y\u0026#39; + mapDataSo.sceneName; /* 对数据进行处理，并将数据存放或更新进入map */ TileDetails tileDetails = new TileDetails { gridPos = new Vector2Int(tileX, tileY), }; if (GetTileDetails(tileDetailKey) != null) { tileDetails = _tileDetailsMap[tileDetailKey]; } /*更新数据*/ switch (tileProperty.gridType) { case GridType.Diggable: tileDetails.canDig = tileProperty.boolTypeValue; break; case GridType.DropItem: tileDetails.canDrop = tileProperty.boolTypeValue; break; case GridType.PlaceFurniture: tileDetails.canPlaceFurniture = tileProperty.boolTypeValue; break; case GridType.NpcObstacle: tileDetails.isNpcObstacle = tileProperty.boolTypeValue; break; } if (GetTileDetails(tileDetailKey) != null) { _tileDetailsMap[tileDetailKey] = tileDetails; } else { _tileDetailsMap.Add(tileDetailKey, tileDetails); } } } } private TileDetails GetTileDetails(string key) { if (_tileDetailsMap.ContainsKey(key)) { return _tileDetailsMap[key]; } return null; } } 让鼠标能够识别地图信息的前提（获取鼠标的坐标） 因此先要获得摄像机的坐标已经当前地图的坐标，由于地图会随着场景切换而改变，因此需要在场景切换后才能获取该坐标\n同时获取世界坐标的功能应该是实时更新的，因此摄像头理论上应该实时改变\n重点函数\n1 2 3 4 Camera.main.ScreenToWorld(new Vector3(Input.mousePosition.x, Input.mousePosition.x, -_mainCamera.transform.position.z)); //鼠标坐标) z轴是因为摄像机距离屏幕有一定距离 // 通过世界坐标转化为网格坐标 Vector3Int = Grid.WorldToCell(世界坐标) 1 2 3 4 5 6 7 8 9 10 // 该函数需要在CursorManager.cs中的Update中调用 private void CheckCursorValid() { /* 获得世界坐标和网格坐标*/ _mouseWorldPos = _mainCamera.ScreenToWorldPoint( new Vector3(Input.mousePosition.x, Input.mousePosition.y, -_mainCamera.transform.position.z)); _mouseGridPos = _currentGrid.WorldToCell(_mouseWorldPos); Debug.Log(\u0026#34;mouseWorld::\u0026#34; + _mouseWorldPos + \u0026#34; mouseGird::\u0026#34; + _mouseGridPos); } 注意由于获得网格坐标我们是在切换场景后才启动的，但是刚刚加入场景的时候，并没有发生场景切换，即此时并没有得到网格坐标，但是在CursorManager中，获取网格坐标是实时更新的，因此会发送报错\n该处的错误需要将在加载初始场景以后，才能执行加载场景后的事件，但是由于加载场景是使用异步加载完成的，因此会导致在加载的过程中，就调用加载后事件了，因此需要通过协程来保证先后顺序，即通过yield return先加载场景，然后再调用加载场景后的时间，因此需要将start函数以协程执行\n协程的含义就是遇到yield return就让出时间片，先不执行后续内容，等yield return执行完成后再执行后续内容\n1 2 3 4 5 6 7 8 // TransitionManager.cs private IEnumerator Start() { yield return LoadSceneSetActive(startSceneName); sceneFaderCanvasGroup = FindObjectOfType\u0026lt;CanvasGroup\u0026gt;(); /*由于将start改为了协程，可以调用场景加载后事件了了*/ EventHandler.CallAfterSceneLoadEvent(); } 上述内容理解：由于yield return的存在，当进行到该start的时候，会先完成场景的加载，然后在场景加载完成后EventHandler.CallAfterSceneLoadEvent();才能被被正常调用\n根据网格信息处理处理鼠标图片 根据地图信息来显示鼠标是可用还是不可用\n**思路：**先获得网格字典中的信息，并将网格字典中的信息和当前选取内容进行比较，从而决定当前鼠标的样式以及当前鼠标是否可使用。\n因此首先需要设计鼠标可用和不可用的样式，然后从GridMapManager中获取内容，将当前物品的信息和地图信息进行比较，然后将物品的信息和人物位置进行比较，最终确定鼠标的状态。\n设置鼠标的图案 1 2 3 4 5 6 7 8 9 private void SetCursorValid() { _cursorImage.color = new Color(1, 1, 1, 1); } private void SetCursorInvalid() { _cursorImage.color = new Color(1, 0, 0, 0.4f); } 1 2 3 4 5 6 7 8 9 10 11 // 获取GridMapManager的信息，此时需要将GridMapManager改为单例模式 /// \u0026lt;summary\u0026gt; /// 通过鼠标的GRID坐标来获取当前地图的信息 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;mousePos\u0026#34;\u0026gt;鼠标的GRID坐标\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TileDetails GetTileDetailsByMousePos(Vector3Int mousePos) { string tileMapKey = mousePos.x + \u0026#34;x\u0026#34; + mousePos.y + \u0026#34;y\u0026#34; + SceneManager.GetActiveScene().name; return GetTileDetails(tileMapKey); } 处理鼠标图案的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /// \u0026lt;summary\u0026gt; /// 实时检测鼠标的位置，并获取地图信息 /// \u0026lt;/summary\u0026gt; private void CheckCursorValid() { /* 获得世界坐标和网格坐标*/ _mouseWorldPos = _mainCamera.ScreenToWorldPoint( new Vector3(Input.mousePosition.x, Input.mousePosition.y, -_mainCamera.transform.position.z)); _mouseGridPos = _currentGrid.WorldToCell(_mouseWorldPos); /*获得人物信息，用于比较人物和鼠标位置, 如果不满足使用范围则 不允许使用*/ Vector3Int playerGridPos = _currentGrid.WorldToCell(playerTransform.position); if (Mathf.Abs(playerGridPos.x - _mouseGridPos.x) \u0026gt; _currentItem.itemUseRadius || Mathf.Abs(playerGridPos.y - _mouseGridPos.y) \u0026gt; _currentItem.itemUseRadius) { SetCursorInvalid(); return; } /*检测当前选取的物品是否满足使用要求*/ TileDetails tileDetails = GridMapManager.Instance.GetTileDetailsByMousePos(_mouseGridPos); if (tileDetails != null \u0026amp;\u0026amp; _cursorEnable) { switch (_currentItem.itemType) { case ItemType.Commodity: if (tileDetails.canDrop \u0026amp;\u0026amp; _currentItem.canDropped) SetCursorValid(); else SetCursorInvalid(); break; } } else { SetCursorInvalid(); } 该过程需要获得人物信息以及当前选取的物品信息，因此需要在对应的事件中获取内容，并且只有当选中某个物品的时候，图标才能被改变形态，其他时候都不能被改变。\n实现鼠标选中物品后的场景点击事件 当鼠标点击后，然后将选取的物品信息和点的坐标，传递给需要的代码\n因此需要一个鼠标的点击事件，然后触发人物的动画，接着再去执行对应的的代码（扔东西，或者树木摇晃）\n由于很多内容涉及到要修改地图信息，因此可以将扔东西等代码放在GridMapManager中执行\n检测点击事件，保证当前位置是可以点击的，然后触发点击事件 1 2 3 4 5 6 7 8 public void CheckPlayerInput() { if (Input.GetMouseButtonDown(0) \u0026amp;\u0026amp; _cursorPositionValid) { /*调用点击事件，并传递当前点击的坐标以及当前触发点击的物品类型*/ EventHandler.CallMouseClickedEvent(_mouseWorldPos, _currentItem); } } 此后人物的脚本应该能接受到该事件，然后完成相应的动画，并在此触发其他事件用以驱动其他代码 1 2 3 4 5 6 // player.cs中挂载的事件 private void OnMouseClickedEvent(Vector3 clickWorldPos, ItemDetails itemDetails) { /*todo 执行对应的动画*/ EventHandler.CallExecuteActionAfterAnimationEvent(clickWorldPos, itemDetails); } 完成丢弃功能，暂时在GridMapManager.cs中执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // GridMapManager.cs // 获得_currentGrid需要通过注册场景切换后事件的方法，然后直接FindObjectOfType\u0026lt;Gird\u0026gt;寻找 private void OnExecuteActionAfterAnimationEvent(Vector3 mouseWorldPos, ItemDetails itemDetails) { /*触发将物品丢弃事件，并需要更新InventoryManager中存储的物品信息，且更新UI*/ Vector3Int mouseGridPos = _currentGrid.WorldToCell(mouseWorldPos); TileDetails currentTile = GetTileDetailsByMousePos(mouseGridPos); if (currentTile != null) { /*Todo携带物品完成不同事件*/ switch (itemDetails.itemType) { case ItemType.Commodity: EventHandler.CallDropItemInSceneEvent(itemDetails.itemID, mouseGridPos); break; } } } 在InventoryManager.cs中实现物品丢弃功能的数据更改，在itemManager.cs实现物品丢弃的地面生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // InventoryManager.cs private void RemoveItem(int itemID, int removeAmount) { /*通过Id获取当前物品在背包中的位置，并判断对应位置的数量*/ int itemIndexInBag = GetItemIndexInBag(itemID); if (playerBag.inventoryItemList[itemIndexInBag].itemAmount \u0026gt; removeAmount) { var amount = playerBag.inventoryItemList[itemIndexInBag].itemAmount - removeAmount; /*更新数据*/ playerBag.inventoryItemList[itemIndexInBag] = new InventoryItem() { itemID = itemID, itemAmount = amount }; } else if (playerBag.inventoryItemList[itemIndexInBag].itemAmount == removeAmount) { playerBag.inventoryItemList[itemIndexInBag] = new InventoryItem(); } EventHandler.CallUpdateInventoryUI(InventoryLocation.Player, playerBag.inventoryItemList); } /// \u0026lt;summary\u0026gt; /// 当丢弃某一个物品时候触发的时间 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;itemID\u0026#34;\u0026gt;丢弃物品的ID\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;pos\u0026#34;\u0026gt;丢弃的坐标\u0026lt;/param\u0026gt; private void OnDropItemInSceneEvent(int itemID, Vector3 pos) { RemoveItem(itemID,1); } 由于丢弃完成所有物品后，格子高亮应该也要清除，并放手，物品不能再被选取，因此需要修改中的清空界面的代码，该段代码是在InventoryUI.cs中调用的SlotUI.cs的UpdateEmptySlot方法，因此需要修改此处。\n注意高亮的更新方法是是slotui的父级GOInventoryUI，以便于高亮一个以后，其他高亮消失\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // SlotUI.cs public void UpdateEmptySlot() { if (isSelected) { isSelected = false; inventoryUI.UpdateSlotHighlight(-1); EventHandler.CallItemSelectedEvent(slotItemDetails, isSelected); } slotItemDetails = null; slotImg.enabled = false; amountText.text = string.Empty; btn.interactable = false; } 由于我们将slotItemDetails = null;设置为了Null，那么相应的所有以slotItemDetails 的数量来判断的地方都要修改，包括slotui以及显示物品信息的窗口\n实现物品被扔出的效果 思路：利用生成物品的移动和阴影来完成视觉差的体验，即物品从人物身边过去，而物品从人物脚底直线过去\n首先需要一个获得阴影的代码，让阴影能够获得本身物品的样子 然后对物体本身使用每一帧更新物体的位置和阴影 最后在itemManager.cs重写丢弃事件的触发代码 由于物体的弹跳需要利用视觉差，因此实际阴影的移动是跟随主物体本身移动的，而物体本身的sprite则从人物头部投出，逐渐到达目标地点\n阴影代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ItemShadow.cs [RequireComponent(typeof(SpriteRenderer))] public class ItemShadow : MonoBehaviour { public SpriteRenderer baseSprite; private SpriteRenderer _shadowSprite; private void Awake() { _shadowSprite = GetComponent\u0026lt;SpriteRenderer\u0026gt;(); } private void Start() { _shadowSprite.sprite = baseSprite.sprite; _shadowSprite.color = new Color(0, 0, 0, 0.3f); } } 物体的移动代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // ItemBounce.cs public class ItemBounce : MonoBehaviour { private Transform Player =\u0026gt; FindObjectOfType\u0026lt;Player\u0026gt;().transform; public float gravity = -3.5f; private Transform _spriteTransform; private BoxCollider2D _collider2D; /*碰撞体，保证人物在丢弃过程中，人物不能捡起*/ /*移动过程需要的参数*/ private bool _inGround; /*是否到达地面*/ private Vector3 _targetPos; /*物体的目标位置*/ private Vector2 _direction; /*物体前进的方向*/ private float _distance; /*物体和目标地点的距离*/ private void Awake() { _spriteTransform = transform.GetChild(0); _collider2D = GetComponent\u0026lt;BoxCollider2D\u0026gt;(); _collider2D.enabled = false; } private void Update() { Bounce(); } /// \u0026lt;summary\u0026gt; /// 对物体需要移动的初始变量进行赋值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;targetPos\u0026#34;\u0026gt;物体的目标距离\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;dir\u0026#34;\u0026gt;物体的目标方向\u0026lt;/param\u0026gt; public void InitBounceItem(Vector3 targetPos, Vector2 dir) { _collider2D.enabled = false; _targetPos = targetPos; _direction = dir; _inGround = false; _distance = Vector3.Distance(transform.position, targetPos); /*保证初始位置在人物的头顶*/ _spriteTransform.position += Vector3.up * 1.75f; } /// \u0026lt;summary\u0026gt; /// 物品弹跳的过程（移动过程） /// \u0026lt;/summary\u0026gt; private void Bounce() { _inGround = _spriteTransform.position.y \u0026lt;= transform.position.y; if (Vector3.Distance(transform.position, _targetPos) \u0026gt; 0.1f \u0026amp;\u0026amp; !_inGround) { /*平面移动*/ transform.position += (Vector3)_direction * _distance * -gravity * Time.deltaTime; } if (!_inGround) { _spriteTransform.position += Vector3.up * 4f * gravity * Time.deltaTime; } else { _spriteTransform.position = transform.position; _collider2D.enabled = true; } } } 实现挖坑效果 为了实现挖坑的图片合理，需要指定绘制瓦片地图的规则\n创建RuleTile的方法，类似于创建空物体的方法在Creat-\u0026gt;2d-\u0026gt;Tile-\u0026gt;ruleTile\n创建好Tile规则以后，需要能绘制对应的挖地和浇水的瓦片，因此也需要通过标签来找到对应的瓦片地图\n然后再GridMapManager.cs中实现当携带工具点击可以挖地或浇水时候的功能，此时需要构建对应的瓦片，因此需要引入对应的瓦片地图的规则，并通过代码获取对应的瓦片地图。\n当可以执行对应的功能的时候，使用TileMap自带的函数TileMap.setTile来设置对应的规则，\n最后在对应的位置设置TileDetiles的具体内容\nGridMapManager的设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 [Header(\u0026#34;瓦片地图规则\u0026#34;)] public RuleTile digRuleTile; public RuleTile waterRuleTile; private Tilemap _digTileMap; /*获得场景的可挖掘地图信息*/ private Tilemap _waterTileMap; /*获得场景的可浇水地图信息*/ /*挖地事件*/ case ItemType.HoeTool: SetDigTileMap(currentTile); currentTile.canDig = false; currentTile.canDrop = false; currentTile.daySinceDig = 0; // todo 音效 break; case ItemType.WaterTool: SetWaterTile(currentTile); currentTile.daySinceWater = 0; break; } } } private void SetDigTileMap(TileDetails tileDetails) { Vector3Int targetTilePos = new Vector3Int(tileDetails.gridPos.x, tileDetails.gridPos.y, 0); if (_digTileMap != null) { _digTileMap.SetTile(targetTilePos, digRuleTile); } } private void SetWaterTile(TileDetails tileDetails) { Vector3Int targetTilePos = new Vector3Int(tileDetails.gridPos.x, tileDetails.gridPos.y, 0); if (_waterTileMap != null) { _waterTileMap.SetTile(targetTilePos, waterRuleTile); } } 设置使用工具的动画 整体思路是在原baseController的基础上，增加新的BlendTree，从而增加不同的状态动画，同时为新的动画添加动画动作，同时设置工具的专门的动画，以实现在不同工具下的动画动作\n设置工具的AnimatorOverride动画，且都基于baseController\n为baseController设置工作的四个方向动画，并使用专门的变量来控制这些方向\n为所有基于baseController的工具动画设置对应的动画片段，并修改角色动画的修改关系\n编写人物触发点击事件时候的动画代码，设置动画的执行过程\n然后设置在人物栏专门添加工具GO，并为其增加动画控制器。\n在AnimatorOverride.cs中该部分逻辑主要是获取当前所持物品的信息，然后找出该物品信息对应的的PartType，找出该需要改变的所有人物拥有的部分（身体，手臂，工具），为这些部分的所有动画控制器更换动画。\n修改人物点击事件的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // player.cs private void OnMouseClickedEvent(Vector3 clickWorldPos, ItemDetails itemDetails) { if (_useTool) return; // 在使用工具则不能点击 /*todo 执行对应的动画*/ if (itemDetails.itemType != ItemType.Seed \u0026amp;\u0026amp; itemDetails.itemType != ItemType.Furniture \u0026amp;\u0026amp; itemDetails.itemType != ItemType.Commodity) { _mouseX = clickWorldPos.x - transform.position.x; _mouseY = clickWorldPos.y - transform.position.y; /*保证不会出现斜方向的动画*/ if (Mathf.Abs(_mouseX) \u0026gt; Mathf.Abs(_mouseY)) { _mouseY = 0; } else { _mouseX = 0; } StartCoroutine(UseToolRoutine(clickWorldPos, itemDetails)); } else { EventHandler.CallExecuteActionAfterAnimationEvent(clickWorldPos, itemDetails); } } /// \u0026lt;summary\u0026gt; /// 执行使用工具的动画，由于是一边动画，一边完成事件，因此要用协程 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;mouseWorldPos\u0026#34;\u0026gt;鼠标点击的位置\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;itemDetails\u0026#34;\u0026gt;使用的物品\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private IEnumerator UseToolRoutine(Vector3 mouseWorldPos, ItemDetails itemDetails) { _useTool = true; _inputDisable = true; yield return null; // 保证此时已经不能移动和使用工具 /*执行动画, 由于在AnimatorOverride.cs中，选择物品就修改动画，因此此时直接执行即可*/ // 将身上所有的动画都按需求执行 foreach (var anim in _animations) { anim.SetTrigger(\u0026#34;useTool\u0026#34;); anim.SetFloat(\u0026#34;MouseX\u0026#34;, _mouseX); anim.SetFloat(\u0026#34;MouseY\u0026#34;, _mouseY); } // 动画执行到一定程度，触发动作的具体代码 yield return new WaitForSeconds(0.45f); EventHandler.CallExecuteActionAfterAnimationEvent(mouseWorldPos, itemDetails); // 等待动画完成 yield return new WaitForSeconds(0.35f); _inputDisable = false; _useTool = false; } 实现地图信息随事件变化 由于每次切换场景瓦片地图数据会消失，但字典中的地图信息保留，因此就需要读取字典信息，并根据内部的内容，将瓦片地图重新绘制\n保存瓦片地图数据（通过每次执行完事件后更新字典信息完成）\n对地图数据进行refresh（每次切换场景，情况所有地图信息，并从字典中重新加载地图信息）\n增加时间对地图信息的影响，每过一天，更新地图信息，并重新绘制地图\n保存瓦片地图的字典信息\n1 2 3 4 5 6 7 8 private void UpdateGridMap(TileDetails tileDetails) { string key = tileDetails.gridPos.x + \u0026#34;x\u0026#34; + tileDetails.gridPos.y + \u0026#34;y\u0026#34; + SceneManager.GetActiveScene(); if (_tileDetailsMap.ContainsKey(key)) { _tileDetailsMap[key] = tileDetails; } } 重绘网格信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /// \u0026lt;summary\u0026gt; /// 删除地图的瓦片信息，并重新生成画面 /// \u0026lt;/summary\u0026gt; private void RefreshGridMap() { if (_digTileMap != null) _digTileMap.ClearAllTiles(); if (_waterTileMap != null) _waterTileMap.ClearAllTiles(); DisplayMap(SceneManager.GetActiveScene().name); } /// \u0026lt;summary\u0026gt; /// 重新生成当前地图的所有绘制内容 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sceneName\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void DisplayMap(string sceneName) { foreach (var tileMapDic in _tileDetailsMap) { // workflow 显示当前地图的后期绘制的瓦片 /*找到当前场景的所有瓦片数据*/ string key = tileMapDic.Key; if (key.Contains(sceneName)) { if (tileMapDic.Value.daySinceDig \u0026gt; -1) SetDigTileMap(tileMapDic.Value); if (tileMapDic.Value.daySinceWater \u0026gt; -1) SetWaterTile(tileMapDic.Value); // todo 种子的瓦片操作 } } } 设置每日更新事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /// \u0026lt;summary\u0026gt; /// 每天更新的事件 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;day\u0026#34;\u0026gt;当前的天数\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;season\u0026#34;\u0026gt;当期的季节\u0026lt;/param\u0026gt; private void OnGameDayEvent(int day, Season season) { /*将所有场景的瓦片信息中，有日期更新的数据都进行更新*/ foreach (var tileDic in _tileDetailsMap) { if (tileDic.Value.daySinceDig \u0026gt; -1) tileDic.Value.daySinceDig++; if (tileDic.Value.daySinceWater \u0026gt; -1) tileDic.Value.daySinceWater = -1; /*如果坑太长时间没有种植，则消失*/ if (tileDic.Value.daySinceDig \u0026gt; 4) { RestoreNotHoe(tileDic.Value); } } RefreshGridMap(); } ","date":"2023-03-05T19:16:38+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E4%B8%83/","title":"麦田物语开发日记(七)"},{"content":"第二场景绘制 设置场景Manager 每次创建新的场景后，都需要先在File-\u0026gt;Builder Settings中将所有场景添加进入列表\n编写场景转化代码TransitionManager.cs **思路：**该部分代码主要实现基础的对场景的异步加载，使用协程的方式完成主要的加载函数，然后使用其他函数对该部分内容进行调用\n而具体调用的函数主要使用事件中心来触发，以减少单例模式的使用\n实现传送点 在场景中设置一个专门的传送点点GO，该GO将传递两个内容，分别是要激活的场景名称和人物生成的坐标，然后调用传送函数即可\n实现场景加载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /// \u0026lt;summary\u0026gt; /// 实现场景的转换 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sceneName\u0026#34;\u0026gt;加载的场景名称\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;transPoint\u0026#34;\u0026gt;传送点\u0026lt;/param\u0026gt; public IEnumerator TransitionScene(string sceneName, Vector3 transPoint) { /* 先卸载当前场景，并使用协程加载当前场景 */ yield return SceneManager.UnloadSceneAsync(SceneManager.GetActiveScene()); yield return LoadSceneSetActive(sceneName); // todo 将人物加载到传送点 } /// \u0026lt;summary\u0026gt; /// 使用协程激活场景 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sceneName\u0026#34;\u0026gt;需要被激活的场景名称\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public IEnumerator LoadSceneSetActive(string sceneName) { /* 使用协程完成场景加载，并激活场景 */ yield return SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Additive); // 由于场景有多个UI和具体场景，因此需要使用叠加的方式 Scene currentScene = SceneManager.GetSceneAt(SceneManager.sceneCount - 1); SceneManager.SetActiveScene(currentScene); } 然后通过事件中心对 协程进行调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void OnEnable() { EventHandler.TransitionEvenet += OnTransitionEvent; } private void OnDisable() { EventHandler.TransitionEvenet -= OnTransitionEvent; } private void OnTransitionEvent(string sceneName, Vector3 transPoint) { StartCoroutine(TransitionScene(sceneName, transPoint)); } 而每个传送点的代码则是直接对事件中心进行调用\n注意每次游戏初期都会加载某一个场景，因此游戏初期需要将所有场景unload，否则导致同时出现两个被加载的场景，在触发场景切换的时候会多次触发。\n完善场景切换的物体切换 由于之前代码中很多内容是在场景建立初期的start中写的，而场景的加载由于会删除场景的物品，因此会导致错误。\n为此需要通过设置两个事件函数BeforeSceneUnloadEvent和AfterSceneloadEvenet两个事件，然后将场景切换会影响的代码需要在注册事件的函数中编写，每次切换场景的时候调用整个事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* 设置场景切换前后的激活事件 */ public static event Action BeforeSceneUnloadEvent; public static event Action AfterSceneLoadEvent; public static void CallBeforeSceneUnloadEvent() { BeforeSceneUnloadEvent?.Invoke(); } public static void CallAfterSceneLoadEvent() { AfterSceneLoadEvent?.Invoke(); } 增加场景修改位置：\n摄像机边界 1 2 3 4 5 6 7 8 9 10 // switchBounds.cs private void OnEnable() { EventHandler.BeforeSceneUnloadEvent += SwitchConfinerShape; } private void OnDisable() { EventHandler.BeforeSceneUnloadEvent -= SwitchConfinerShape; } 修改物品UI并取消高亮显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // inventoryUI.cs private void OnEnable() { EventHandler.UpdateInventoryUI += OnUpdateInventoryUI; EventHandler.BeforeSceneUnloadEvent += OnBeforeSceneUnloadEvent; } private void OnDisable() { EventHandler.UpdateInventoryUI -= OnUpdateInventoryUI; EventHandler.BeforeSceneUnloadEvent -= OnBeforeSceneUnloadEvent; } private void OnBeforeSceneUnloadEvent() { /*切换场景前取消高亮显示*/ UpdateSlotHighlight(-1); } 为每个场景增加itemParent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // itemManager.cs private void OnEnable() { EventHandler.InstantiateItemInScene += OnInstantiateItemInScene; EventHandler.AfterSceneLoadEvent += OnAfterSceneLoadEvent; } private void OnDisable() { EventHandler.InstantiateItemInScene -= OnInstantiateItemInScene; EventHandler.AfterSceneLoadEvent -= OnAfterSceneLoadEvent; } private void OnAfterSceneLoadEvent() { _itemParent = GameObject.FindGameObjectWithTag(\u0026#34;ItemParent\u0026#34;); } 最后将人物举起物品功能进行修正，每次切换场景则放下物品，并让高亮取消\n设置人物在场景移动的功能，使用事件中心去通知对应的转移函数。\n学习编写特性，并将其设置为下拉菜单 Unity的特性Attribute可以将Unity界面显示的变量(Property)修改为我们期望的样子，比如将手写的string输入框设置为下拉菜单的模式。\n而具体的做法是将需要修改的变量property，在前方增加描述[Attribute]，然后编写一个用于描述该Attribute的代码SceneNameAttribute，其继承自PropertyAttribute;然后编写一个用于绘制对应GUI的代码SceneNameDrawer，该代码继承自PropertyDrawer，用于描述该特性怎么描述GUI。\n注意这两部分代码不能放在原本绘制UI toolkit的位置，否则不能使用，因此放在Utility的位置\n1 2 3 4 5 6 7 // SceneNameAttribute的写法，只需要明确有这个特性 using UnityEngine; public class SceneNameAttribute : PropertyAttribute { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 // SceneNameDrawer.cs ，需要将GUI的内容都确定下来，并对其进行赋值 using System; using UnityEditor; using UnityEngine; [CustomPropertyDrawer(typeof(SceneNameAttribute))] public class SceneNameDrawer: PropertyDrawer { private int sceneIndex = -1; // 当前选取的场景编号 private string[] _sceneNameSplits = { \u0026#34;/\u0026#34;, \u0026#34;.unity\u0026#34; }; // 由于BuildingSetting中场景有路径，因此需要被删除一部分 private GUIContent[] _sceneNames; // 显示在GUI上的文本内容 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { /*如果场景数为0，则不再绘制*/ if (EditorBuildSettings.scenes.Length == 0) return; /*从buildSetting中找出所有的场景名称*/ if (sceneIndex == -1) GetSceneNameArray(property); int oldIndex = sceneIndex; /*绘制GUI，并设置GUI点击的内容为我们的目标值*/ // Popup参数分别是绘制的位置，显示的载体，要显示的内容的需要，下拉菜单的具体内容 sceneIndex = EditorGUI.Popup(position, label, sceneIndex, _sceneNames); if (oldIndex != sceneIndex) property.stringValue = _sceneNames[sceneIndex].text; } private void GetSceneNameArray(SerializedProperty property) { // 获得当前BuildingSetting中所有的场景数据 var scenes = EditorBuildSettings.scenes; /*对获取场景数据的函数进行初始化*/ _sceneNames = new GUIContent[scenes.Length]; /*通过循环将场景名称放入GUI的数组内容中*/ for (int i = 0; i \u0026lt; scenes.Length; i++) { string path = scenes[i].path; string[] scenePath = path.Split(_sceneNameSplits, StringSplitOptions.RemoveEmptyEntries); string sceneName = String.Empty; if (scenePath.Length \u0026gt; 0) { sceneName = scenePath[scenePath.Length - 1]; } else { sceneName = \u0026#34;(Delete Scene)\u0026#34;; } _sceneNames[i] = new GUIContent(sceneName); } if (_sceneNames.Length == 0) _sceneNames = new[] { new GUIContent(\u0026#34;Check your Build Settings\u0026#34;) }; /*对property中的内容进行赋值，首先需要确保如果内容不为空，那么其必须是我们设置的场景名称*/ if (!string.IsNullOrEmpty(property.stringValue)) { bool nameFound = false; for (int i = 0; i \u0026lt; _sceneNames.Length; i++) { if (property.stringValue == _sceneNames[i].text) { sceneIndex = i; nameFound = true; break; } } if (!nameFound) { sceneIndex = 0; } } else { sceneIndex = 0; } /*用刚刚获得sceneIndex对应的场景名，对property进行赋值*/ property.stringValue = _sceneNames[sceneIndex].text; } } 过渡动画 思路：通过设置一个新的Canvas，增加一个覆盖层，通过对该覆层的透明度进行修改来实现过渡动画，该覆盖层可以通过设置CanvasGroup组件来保证其子物体也能一同进行淡入淡出的过渡。\n而具体的执行函数将在TransitionManager.cs中通过协程进行完成。\n注意：为了保存新的覆层能够覆盖整个屏幕，需要将该Canvas的排序进行修改\n具体做法，首先设置一个Canvas，设置号Canvas相关的属性后，屏幕尺寸和排序（必须），然后在Canvas下创建一个Panel，即该Panel就是一个覆层。然后对该Panel设置对应的CanvasGroup以保证画布中的内容能一同渐变，然后通过的代码对整个Canvas进行控制即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /// \u0026lt;summary\u0026gt; /// 场景渐变 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;targetAlpha\u0026#34;\u0026gt;1为全覆盖，0为不覆盖\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public IEnumerator SceneFader(float targetAlpha) { isFading = true; sceneFaderCanvasGroup.blocksRaycasts = true; // 当前图片不能点击 /*使用数学方法计算场景的渐变过程速度*/ float speed = Mathf.Abs(targetAlpha - sceneFaderCanvasGroup.alpha) / Settings.SceneFaderDuration; while (!Mathf.Approximately(sceneFaderCanvasGroup.alpha, targetAlpha)) { // 如果没达到目标，则不断将当前的透明度向目标移动 sceneFaderCanvasGroup.alpha = Mathf.MoveTowards(sceneFaderCanvasGroup.alpha, targetAlpha, speed * Time.deltaTime); yield return null; } isFading = false; sceneFaderCanvasGroup.blocksRaycasts = false; } 其中isFading用于标志只用当渐变结束，才能移动目标\n保存和加载场景物品 思路：每次卸载场景的时候，用一个内容记录场景中所有物体的内容和坐标，然后加载场景的时候读取并生成即可。因此使用一个哈希表用于存储相关内容，key为场景名称，value为需要存储数据的列表。\n注意在生成数据的时候，需要先将场景中原有的数据都删除，防止重复生成。\n由于Vector3在一个类中不能被序列化，因此需要设计一个专门的类用来描述Vector3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 在dataCollection.cs中描述保存Item位置的变量 /// \u0026lt;summary\u0026gt; /// 定义一个能被Unity识别的Vector3 /// \u0026lt;/summary\u0026gt; [System.Serializable] public class SerializableVector3 { public float x, y, z; public SerializableVector3(Vector3 pos) { this.x = pos.x; this.y = pos.y; this.z = pos.z; } public Vector3 ToVector3() { return new Vector3(x, y, z); } /*获得瓦片地图的位置*/ public Vector2 ToVector2() { return new Vector2((int)x, (int)y); } } /// \u0026lt;summary\u0026gt; /// 定义场景中item的描述类 /// \u0026lt;/summary\u0026gt; [System.Serializable] public class SceneItem { public int itemId; public SerializableVector3 itemPos; } 存储与读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 /// \u0026lt;summary\u0026gt; /// 将场景中所有item存储进入字典中 /// \u0026lt;/summary\u0026gt; private void GetAllSceneItem() { /*获取当前场景的所有item*/ List\u0026lt;SceneItem\u0026gt; currentItems = new List\u0026lt;SceneItem\u0026gt;(); foreach (var item in FindObjectsOfType\u0026lt;Item\u0026gt;()) { SceneItem sceneItem = new SceneItem { itemId = item.itemID, itemPos = new SerializableVector3(item.transform.position) }; currentItems.Add(sceneItem); } /*将场景中所有的item存放在对应的dict中*/ if (_sceneItemDict.ContainsKey(SceneManager.GetActiveScene().name)) { _sceneItemDict[SceneManager.GetActiveScene().name] = currentItems; } else { _sceneItemDict.Add(SceneManager.GetActiveScene().name, currentItems); } } /// \u0026lt;summary\u0026gt; /// 重建当前场景中的所有item /// \u0026lt;/summary\u0026gt; public void ReBuildSceneItems() { List\u0026lt;SceneItem\u0026gt; currentItems = new List\u0026lt;SceneItem\u0026gt;(); /*获取字典中当前场景item的存储*/ if (_sceneItemDict.TryGetValue(SceneManager.GetActiveScene().name, out currentItems)) { if (currentItems != null) { // 先将当前场景清场，防止有代码遗漏的物品 foreach (var item in FindObjectsOfType\u0026lt;Item\u0026gt;()) { Destroy(item.gameObject); } // 重建所有内容 foreach (var item in currentItems) { Item newItem = Instantiate(itemPrefab, item.itemPos.ToVector3(), Quaternion.identity, _itemParent.transform); newItem.InitItem(item.itemId); } } } } ","date":"2023-03-05T19:16:36+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%85%AD/","title":"麦田物语开发日记(六)"},{"content":"时间系统 时间系统的代码逻辑 思路\n该部分主要通过两个重要的机制来完成，每秒的阈值和每个时间单位的进制来组合实现，每秒阈值通过使用Unity自带的Times.deltaTime的累加实现，如果超过该阈值，则进一秒，因此当阈值越低，游戏内的时间流动越快。\n而且游戏中时间流逝的进制在设置好以后通过每秒的递增来通过if语句体现\n设置时间的阈值和单位进制 1 2 3 4 // 放入settings.cs中便于修改 /*时间控制*/ public const float GameTimeThreshold = 0.1f; // 每秒的时间长度，数值越小时间越快 public const int GameSecondHold = 59, GameMinuteHold = 59, GameHourHold = 23, GameDayHold = 10, GameMonthHold = 12, GameSeasonHold = 3; // 时间的进制 设置季节枚举（略过） 设置时间的增长 利用deltaTime机制，当计时器超过游戏中每秒的刻度，就增加游戏秒一次，并调用计时函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // TimeManager.cs中的方法 private void Update() { if (!_gameClockPause) { tikTime += Time.deltaTime; if (tikTime \u0026gt;= Settings.GameTimeThreshold) { tikTime -= Settings.GameTimeThreshold; UpdateGameTime(); } } } 计时增长函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // TimeManager.cs中的方法 /*时间单位*/ private int _gameSeconds, _gameMinutes, _gameHours, _gameDays, _gameMonth, _gameYears; /*时间的计数遍历*/ private Season _currentSeason = Season.Spring; private int _monthInSeason = 3; // 每个季度的月份 private bool _gameClockPause; private float tikTime; // 计时器 // 每次新开游戏的初始化 private void newGameTime() { tikTime = 0f; _gameClockPause = false; _gameSeconds = 0; _gameMinutes = 0; _gameHours = 0; _gameDays = 1; _gameMonth = 1; _gameYears = 1; _currentSeason = Season.Spring; } /// \u0026lt;summary\u0026gt; /// 更新游戏时间, 游戏世界的每一秒都要调用一次的函数， /// \u0026lt;/summary\u0026gt; private void UpdateGameTime() { _gameSeconds++; // 如果累计时间超过了时间的进制单位，则进位 if (_gameSeconds \u0026gt; Settings.GameSecondHold) { _gameMinutes++; _gameSeconds = 0; if (_gameMinutes \u0026gt; Settings.GameMinuteHold) { _gameHours++; _gameMinutes = 0; if (_gameHours \u0026gt; Settings.GameHourHold) { _gameDays++; _gameHours = 0; if (_gameDays \u0026gt; Settings.GameDayHold) { _gameMonth++; _gameDays = 1; _monthInSeason--; if (_gameMonth \u0026gt; Settings.GameMonthHold) _gameMonth = 1; if (_monthInSeason == 0) { _monthInSeason = 3; int seasonNumber = (int)_currentSeason; seasonNumber++; if (seasonNumber \u0026gt; Settings.GameSecondHold) { seasonNumber = 0; _gameYears++; _gameYears %= 9999; } } } } } } // // Debug.Log(\u0026#34;now Seconds is :\u0026#34; + _gameSeconds + \u0026#34;:: Minutes is \u0026#34; + _gameMinutes); } 在该函数中，由于每秒刻度为0.1f，也就是说将现实一秒分为了10份，每一份是游戏中的一秒，那么现实世界每6秒相当于游戏内一分钟\n构建时间UI 在UI的大Canvas下构建一个基础的panel用于构造时间框体，然后不断的在内部增加图片层次。\n为了实现只显示图片一部分，因此要利用遮罩效果 该方法是先设置一个主要显示内容的图片，然后将需要被显示的图像设置为该图像的子物体，然后对父物体使用Mask组件。而具体需要显示的内容则通过旋转得到\n为了让所有图片都在同一部分，以设置每个时钟块，因此先定好整个物体的位置（用Image本身来定位），然后将image删除，将定位好的物体作为父物体，然后设置每个子物体的位置\n为了让btn的图片按键准确，需要对该精灵图片设置的advanced - \u0026gt; Read/Write进行勾选，这样才能保证不会点击图片空白处\n连接时间代码和UI **思路：**在时间的UI代码中绑定一个UI变化函数，并在时间流逝代码中，每次分钟和小时变化的时候，调用这个事件，从而引起UI的变化；而图标等则通过代码进行变化。\n步骤\n构造UI代码，并建立对应的UI部件\n定义UI变化的事件，并将事件与UI变化代码绑定\n在时间变化函数中呼叫事件\n构造UI代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 在TimeUI.cs中定义使用的所有组件，并绑定信息 public RectTransform dayNightImage; public RectTransform timeBlockParent; public Image seasonImg; public TextMeshProUGUI dateText; public TextMeshProUGUI timeText; public Sprite[] seasonSprites; private List\u0026lt;GameObject\u0026gt; _timeBlocks = new List\u0026lt;GameObject\u0026gt;(); private void Awake() { /* 为时间块绑定子物体 */ for (int i = 0; i \u0026lt; timeBlockParent.childCount; i++) { _timeBlocks.Add(timeBlockParent.GetChild(i).gameObject); timeBlockParent.GetChild(i).gameObject.SetActive(false); } } 对时间调用事件进行设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // EventHandler.cs /* 每分钟更新的事件 */ public static event Action\u0026lt;int, int\u0026gt; GameMinuteEvent; public static void CallGameMinuteEvent(int minute, int hour) { GameMinuteEvent?.Invoke(minute, hour); } /* 小时和日期更新的事件 */ public static event Action\u0026lt;int, int, int, int, Season\u0026gt; GameDateEvent; public static void CallGameDateEvent(int hour, int day, int month, int year, Season season) { GameDateEvent?.Invoke(hour, day, month, year, season); } 上述函数将在TimeManager.cs的每分钟更新和每小时更新中进行使用，并且需要保证每次游戏一开始就需要更新，且由于事件是在OnEnable中绑定的，因此一开始的调用只能在Start中\n更新UI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 在TimeUI中定义UI变化的函数 private void OnGameDateEvent(int hour, int day, int month, int year, Season season) { dateText.text = year.ToString(\u0026#34;0000\u0026#34;) + \u0026#34;年\u0026#34; + month.ToString(\u0026#34;00\u0026#34;) + \u0026#34;月\u0026#34; + day.ToString(\u0026#34;00\u0026#34;) + \u0026#34;日\u0026#34;; seasonImg.sprite = seasonSprites[(int)season]; SwitchHourBlockImage(hour); DayNightImageRotate(hour); } private void OnGameMinuteEvent(int min ,int hour) { timeText.text = hour.ToString(\u0026#34;00\u0026#34;) + \u0026#34;:\u0026#34; + min.ToString(\u0026#34;00\u0026#34;); } /// \u0026lt;summary\u0026gt; /// 对时间块进行处理,每四个小时亮一块 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;hour\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void SwitchHourBlockImage(int hour) { var index = hour / 4; for (int i = 0; i \u0026lt; _timeBlocks.Count; i++) { if (i \u0026lt; index + 1) { _timeBlocks[i].SetActive(true); } else { _timeBlocks[i].SetActive(false); } } } /// \u0026lt;summary\u0026gt; /// 对时间图片进行旋转 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;hour\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void DayNightImageRotate(int hour) { var targetRotate = hour * 15 - 90; dayNightImage.DORotate(new Vector3(0, 0, targetRotate), 1f); } dayNightImage.DORotate是DC.Tweening的函数，用于对图片进行旋转，其第一个参数是旋转的目标位置\n","date":"2023-03-05T19:16:34+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E4%BA%94/","title":"麦田物语开发日记(五)"},{"content":"人物动画 制作Player动画 思路 构建一个基础的四方向行动的AnimeController，该控制器包含每个每个方向的站立，走路，跑步的动画，然后基于该baseController构建每个身体部位的动画控制器 为每个部位的各个动画组件构建对应的动画，并将对应对应到身体各个部位的动画控制器上 最后在角色移动的代码中增加动画的控制器，并设置切换代码 基础Controller通过Blend Tree来控制多个方向的站立和跑动，因此站立和跑动都应该是一个Blend Tree。在站立中，由于是面向某个方向，因此对应的方向应该是只是个普通的动画；\n在移动中，由于涉及走路和跑动的改变，因此需要基础的Blend Tree内部嵌套BlenderTree\n在跑动的Blend Tree中，需要嵌套Blend Tree的移动\n且每个具体的动动作都需要设置对应的阈值，且方向与input移动的轴的方向相统一（左侧则阈值为负数）\n然后使用Animator Override Controller创建每个身体部位对应的控制器，并创建每个身体部位对应的动画，将其挂载到控制器中。\n修改人物移动代码 由于有多个animator，因此需要通过循环来让每个控制器都设置我们的输入，让其控制动画进行\n1 2 3 4 5 6 7 8 9 10 11 12 13 private void SwitchPlayerAnima() { foreach (var anima in _animations) { anima.SetBool(\u0026#34;IsMoving\u0026#34;, _isMoving); if (_isMoving) { anima.SetFloat(\u0026#34;InputX\u0026#34;, _inputX); anima.SetFloat(\u0026#34;InputY\u0026#34;, _inputY); } } } 该部分需要在update中执行，其中_isMoving的赋值人物控制的代码中进行判断的\n实现物体举起动画 **拓展：**通过该方法的学习，能够了解如果实现切换衣服和装备等\n实现思路：\n首先创建一个用于承接所有被举起物品的Sprite，当物品被选中时，就使该图片出现 为了实现动画的切换，我们需要设置每套独立的动画控制器 用一个独立的代码来控制不同种类和不同动画控制器的对应关系 为了正确找到不同的动画，我们需要为每个待切换的动画设置对应的类别，以便寻找，（因此采用枚举的方式来这是不同的动画种类和承接动画的部位名称；用字典来绑定动画种类和动画控制器 用事件中心的方式来通知切换动画 当需要切换动画的时候，通过字典来得到的承接动画的部位类型来找出需要被切换的动画 添加切换状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 角色所处的状态 /// \u0026lt;/summary\u0026gt; public enum PartType { None, Carry, Break, Hoe } /// \u0026lt;summary\u0026gt; /// 角色的身体部位 /// \u0026lt;/summary\u0026gt; public enum PartName { Hair, Body, Arm } 1 2 3 4 5 6 7 8 9 10 11 12 /// \u0026lt;summary\u0026gt; /// 每个动画控制器与角色的状态对应关系 /// \u0026lt;/summary\u0026gt; [System.Serializable] public class AnimatorType { public PartType partType; public PartName partName; public AnimatorOverrideController overrideController; } 独立代码绑定动画到字典，字典的key是身体部位的name，value是当前对应的身体GO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // DataConllection.cs public class AnimatorOverride : MonoBehaviour { private Animator[] _animators; public SpriteRenderer holdItem; [Header(\u0026#34;角色动画与当前状态的关系\u0026#34;)] public List\u0026lt;AnimatorType\u0026gt; animatorTypes; public Dictionary\u0026lt;string, Animator\u0026gt; AnimatorNameDict = new Dictionary\u0026lt;string, Animator\u0026gt;(); private void Awake() { _animators = GetComponentsInChildren\u0026lt;Animator\u0026gt;(); foreach (var anim in _animators) { AnimatorNameDict.Add(anim.name, anim); } } } 添加切换事件到事件中心 1 2 3 4 5 6 7 // EventHandler.cs public static event Action\u0026lt;ItemDetails, bool\u0026gt; ItemSelectedEvent; public static void CallItemSelectedEvent(ItemDetails itemDetails, bool isSelected) { ItemSelectedEvent?.Invoke(itemDetails, isSelected); } 激活事件 1 2 3 4 5 6 // slotUI.cs /* 当物品被点击的时候，背包中的物品会被举起 */ if (slotType == SlotType.Bag) { EventHandler.CallItemSelectedEvent(slotItemDetails, isSelected); } 切换动画的具体过程 首先我们需要通过得到当前点击的物品来了解我们应该处于什么状态，然后根据这个状态，来从animatorType中找到我们预先设定好的用来替换当前动画的的controller\n而通过字典寻找切换状态的方式是，保证构建的GO和animatorType中定义的替换部位的枚举类型name一致，这就可以通过字典进行查询。\n1 2 3 4 5 6 7 8 9 10 11 12 13 private void OnItemSelectedEvent(ItemDetails itemDetails, bool isSelected) { /*当点击时，根据当前的物品类型获得人物应该处于的状态*/ var currentType = itemDetails.itemType switch { ItemType.Seed =\u0026gt; PartType.Carry, ItemType.Commodity =\u0026gt; PartType.Carry, _ =\u0026gt; PartType.None }; /* 执行动画的切换 */ SwitchAnimator(currentType); } 从我们的可替换列表中找出所有当前状态可替换的动画类型，然后通过该动画类型对应的身体部位GO，替换其正在运行的动画控制器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void SwitchAnimator(PartType partType) { /* 从所有待备选方案中找出需要用来替换的animator */ foreach (var animatorType in animatorTypes) { if (animatorType.partType == partType) { // 此时的字典的key对应的是承接动画的身体部位的name AnimatorNameDict[animatorType.partName.ToString()].runtimeAnimatorController = animatorType.overrideController; } } } 优化 保证是isSelected和当前的状态应该是Carry的情况下，才能显示被举起的图片\n","date":"2023-03-05T19:16:32+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E5%9B%9B/","title":"麦田物语开发日记(四)"},{"content":"背包系统 物品属性的基本设置 使用MVC架构来控制数据控制和显示\n因此需要定义相关的物品内容的类和物品类型的枚举变量\n1 2 3 4 5 6 public enum ItemType { Seed, Commodity, Furniture, HoeTool, ChopTool, BreakTool, ReapTool, WaterTool, CollectTool, ReapableScenery } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // DataCollections.cs /// \u0026lt;summary\u0026gt; /// 该类收集写过的所有类，结构体, /// \u0026lt;/summary\u0026gt; [System.Serializable] // 保证写过的所有类和结构体都能被Unity识别，因此需要为其序列化 public class ItemDetails { public int itemID; public string itemName; public ItemType itemType; public Sprite itemIcon; // 物品的图标 public Sprite itemOnWorldSprite; // 在世界地图上物品的样子，比如种子 public int itemUseRadius; // 物品的可适用范围 public bool canPickUp; public bool canDropped; public bool canCarried; public int itemPrice; [Range(0, 1)] public float sellPercentage; // 售卖时候的折扣范围 } 在两个类的基础上，可以通过定义对应的ScriptableObeject来定义我们的物品信息，由于物品较多，因此在SO中可以通过一个列表的形式去定义多个物品信息\n1 2 3 4 5 [CreateAssetMenu(fileName = \u0026#34;ItemDataList_SO\u0026#34;, menuName = \u0026#34;Inventory/ItemDetails\u0026#34;)] public class ItemDataList_SO : ScriptableObject { public List\u0026lt;ItemDetails\u0026gt; itemDetailsList; } 使用UIToolkit来完成物品的内容的设置 UIToolKit可以帮我们定义一个可视化的编辑内容的方案\n新建一个Editor文件夹用于管理我们的所有可编辑内容，在下面建立存放UItoolkit的文件夹UI Builder，然后新建一个Uitoolkit -\u0026gt; Editor window，分为三个文件，用于管理GUI的脚本，Unity独特的XML格式文件，以及一个类似CSS的内容。\n每一个UitoolKit的窗口都有一个根节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class ItemEditor : EditorWindow { [MenuItem(\u0026#34;Window/UI Toolkit/ItemEditor\u0026#34;)] public static void ShowExample() { ItemEditor wnd = GetWindow\u0026lt;ItemEditor\u0026gt;(); wnd.titleContent = new GUIContent(\u0026#34;ItemEditor\u0026#34;); } public void CreateGUI() { // Each editor window contains a root VisualElement object VisualElement root = rootVisualElement; // VisualElements objects can contain other VisualElement following a tree hierarchy. VisualElement label = new Label(\u0026#34;Hello World! From C#\u0026#34;); root.Add(label); // Import UXML var visualTree = AssetDatabase.LoadAssetAtPath\u0026lt;VisualTreeAsset\u0026gt;(\u0026#34;Assets/Editor/UI Builder/ItemEditor.uxml\u0026#34;); VisualElement labelFromUXML = visualTree.Instantiate(); root.Add(labelFromUXML); // A stylesheet can be added to a VisualElement. // The style will be applied to the VisualElement and all of its children. var styleSheet = AssetDatabase.LoadAssetAtPath\u0026lt;StyleSheet\u0026gt;(\u0026#34;Assets/Editor/UI Builder/ItemEditor.uss\u0026#34;); VisualElement labelWithStyle = new Label(\u0026#34;Hello World! With Style\u0026#34;); labelWithStyle.styleSheets.Add(styleSheet); root.Add(labelWithStyle); } } 绘制可视化的编辑工具\n直接使用对应的UiBuilder，作为编辑窗口，可视化的编辑我们的UI ToolKit\n在UI builder中，每一个VisualElement可以看做是一个div\n和写页面类似\n将数据与制作的UIToolKit绑定 在ItemUI的界面中将所有ItemData数据通过代码进行加载，并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class ItemEditor : EditorWindow { private ItemDataList_SO _dataBase; private List\u0026lt;ItemDetails\u0026gt; _itemDetailsList = new List\u0026lt;ItemDetails\u0026gt;(); // 用于获得对应列表的内容 /// \u0026lt;summary\u0026gt; /// 从Asset文件夹下找出我们的ItemDataList_SO，并加载当GUI中 /// \u0026lt;/summary\u0026gt; private void LoadDataBase() { // 通过类似的名称找出其对应的GUID数组 var dataStringArrs = AssetDatabase.FindAssets(\u0026#34;t:ItemDataList_SO\u0026#34;);\t// t:用于指定我们要找到文件的类型，可以不写 if (dataStringArrs.Length \u0026gt; 0) { // 基于数组中的路径找出我们需要的Item数据类型 var path = AssetDatabase.GUIDToAssetPath(dataStringArrs[0]); _dataBase = AssetDatabase.LoadAssetAtPath\u0026lt;ItemDataList_SO\u0026gt;(path); } _itemDetailsList = _dataBase.itemDetailsList; // 必须标注了才能保存数据 EditorUtility.SetDirty(_dataBase); } } 每次获得数据，由于界面已经加载，因此需要将数据设置为脏数据，才能表示重新加载了数据\n将获得的itemList的数据显示在左侧的ListView界面上\n获得界面上的ListView组件内容，然后将该组件的通过Unity自带的代码进行显示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class ItemEditor : EditorWindow { private ListView _itemListView; public void CreateGUI() { // 获得模板数据 // 通过绝对路径找到我们的模板 _itemRowTemplate = AssetDatabase.LoadAssetAtPath\u0026lt;VisualTreeAsset\u0026gt;(\u0026#34;Assets/Editor/UI Builder/ItemRowTemplate.uxml\u0026#34;); // 获得listView _itemListView = root.Q\u0026lt;VisualElement\u0026gt;(\u0026#34;container\u0026#34;).Q\u0026lt;VisualElement\u0026gt;(\u0026#34;ItemList\u0026#34;).Q\u0026lt;ListView\u0026gt;(\u0026#34;ListView\u0026#34;); // 在ListView中显示数据 GenerateListView(); } /// \u0026lt;summary\u0026gt; /// 生成ListView相关内容 /// \u0026lt;/summary\u0026gt; private void GenerateListView() { // 告诉界面每个item应该是什么样子的 Func\u0026lt;VisualElement\u0026gt; makeItem = () =\u0026gt; _itemRowTemplate.CloneTree(); // 告诉界面每个item的内容该用什么去匹配 （element表示一个具体的组件，index表示当前组件的下标） Action\u0026lt;VisualElement, int\u0026gt; bindItem = (element, index) =\u0026gt; { if (index \u0026lt; _dataBase.itemDetailsList.Count) { var item = _itemDetailsList[index]; // 通过Q\u0026lt;type\u0026gt;(name) 来寻找每个item的具体内容 if (item.itemIcon != null) element.Q\u0026lt;VisualElement\u0026gt;(\u0026#34;Icon\u0026#34;).style.backgroundImage = _itemDetailsList[index].itemIcon.texture; element.Q\u0026lt;Label\u0026gt;(\u0026#34;ItemName\u0026#34;).text = item.itemName != null ? item.itemName : \u0026#34;No Item\u0026#34;; } }; _itemListView.fixedItemHeight = 60; // 固定高度 _itemListView.makeItem += makeItem; _itemListView.bindItem += bindItem; _itemListView.itemsSource = _itemDetailsList; // Callback invoked when the user double clicks an item _itemListView.onItemsChosen += Debug.Log; // Callback invoked when the user changes the selection inside the ListView _itemListView.onSelectionChange += Debug.Log; } } 将数据信息于右侧的具体数值进行显示\n为了保证在面板上修改的值能够同步到具体的data_SO中，需要使用专门的函数，设置为脏函数\n在这一过程，主要是需要通过Q\u0026lt;type\u0026gt;(name)去找出所有的组件内容，然后面板信息绑定从itemList中得到的值\n因此首先需要在每次选择某一个item时获得对应的内容OnSelecttionChange事件，然后将其内容同步到右侧面板上\n_itemListView.onSelectionChange += OnListSelectionChange;\n每次绑定好一个item和对应的面板后需要同时为其绑定对应的回调函数，保证能及时同步到SO上\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// \u0026lt;summary\u0026gt; /// 当选中某一个item的时候的回调 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;selectedItem\u0026#34;\u0026gt;所有被选中的item，实际只有一个\u0026lt;/param\u0026gt; private void OnListSelectionChange(IEnumerable\u0026lt;object\u0026gt; selectedItem) { if (selectedItem != null) { _activeItem = selectedItem.First() as ItemDetails; // 强转 GetItemDetails(); _itemDetailsSection.visible = true; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /// \u0026lt;summary\u0026gt; /// 绑定item内容 /// \u0026lt;/summary\u0026gt; private void GetItemDetails() { // 设置了该函数面板中数据的更改 可以同步到SO中 _itemDetailsSection.MarkDirtyRepaint(); _itemDetailsSection.Q\u0026lt;IntegerField\u0026gt;(\u0026#34;ItemID\u0026#34;).value = _activeItem.itemID; // 回调函数，保证在面板上的修改能同步到我们的SO中 _itemDetailsSection.Q\u0026lt;IntegerField\u0026gt;(\u0026#34;ItemID\u0026#34;).RegisterValueChangedCallback((evt) =\u0026gt; { _activeItem.itemID = evt.newValue; }); // 获得Name _itemDetailsSection.Q\u0026lt;TextField\u0026gt;(\u0026#34;ItemName\u0026#34;).value = _activeItem.itemName; _itemDetailsSection.Q\u0026lt;TextField\u0026gt;(\u0026#34;ItemName\u0026#34;).RegisterValueChangedCallback(evt =\u0026gt; { _activeItem.itemName = evt.newValue; _itemListView.Rebuild(); // 当更新名称和图标的时候重新绘制 }); // 获得类型 _itemDetailsSection.Q\u0026lt;EnumField\u0026gt;().value = _activeItem.itemType; } 更新图片icon\n1 2 3 4 5 6 7 8 9 10 11 12 // 实现图片的修改（思路：默认获得_activeItem的图片，如果需要修改图片，选择图片以后，修改显示图片的背景) _iconPreview.style.backgroundImage = _activeItem.itemIcon != null ? _activeItem.itemIcon.texture :_defaultIcon.texture; _itemDetailsSection.Q\u0026lt;ObjectField\u0026gt;(\u0026#34;ItemIconSprite\u0026#34;).value = _activeItem.itemIcon; _itemDetailsSection.Q\u0026lt;ObjectField\u0026gt;(\u0026#34;ItemIconSprite\u0026#34;).RegisterValueChangedCallback(evt =\u0026gt; { // 每次回调都需要更新 Sprite newIcon = (Sprite)evt.newValue; _activeItem.itemIcon = newIcon; _iconPreview.style.backgroundImage = _activeItem.itemIcon != null ? newIcon.texture :_defaultIcon.texture; _itemListView.Rebuild(); }); 添加item和删除item\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 在GUI主函数中为button添加对应的事件 // 获得添加和删除按钮的具体事件 public void CreateGUI() { root.Q\u0026lt;Button\u0026gt;(\u0026#34;AddButton\u0026#34;).clicked += OnAddBtnClicked; root.Q\u0026lt;Button\u0026gt;(\u0026#34;DelButton\u0026#34;).clicked += OnDelBtnClicked; } // # region 按键事件 private void OnDelBtnClicked() { // 从_itemDetailsList中移除activeItem，然后重新绘制 if (_activeItem != null) { _itemDetailsList.Remove(_activeItem); _itemListView.Rebuild(); _itemDetailsSection.visible = false; } } private void OnAddBtnClicked() { _itemDetailsSection.visible = true; ItemDetails newItem = new ItemDetails(); newItem.itemName = \u0026#34;New Item\u0026#34;; newItem.itemID = 1000 + _itemDetailsList.Count; newItem.itemIcon = AssetDatabase.LoadAssetAtPath\u0026lt;Sprite\u0026gt;(Settings.DefaultIconPath); _itemDetailsList.Add(newItem); _itemListView.Rebuild(); } # endregion 注意绑定枚举类型时需要先将其初始化\n1 2 3 4 5 6 _itemDetailsSection.Q\u0026lt;EnumField\u0026gt;(\u0026#34;ItemType\u0026#34;).Init(_activeItem.itemType); _itemDetailsSection.Q\u0026lt;EnumField\u0026gt;(\u0026#34;ItemType\u0026#34;).value = _activeItem.itemType; _itemDetailsSection.Q\u0026lt;EnumField\u0026gt;(\u0026#34;ItemType\u0026#34;).RegisterValueChangedCallback(evt =\u0026gt; { _activeItem.itemType = (ItemType)evt.newValue; }); 物品管理逻辑 所有的物品都通过inventoryManager来控制\n使用单例模式创建InventoryManage并构建对应的命名空间来管理需要的数据，所有跟背包、数据有关的内容都需要调用该命名空间，这样其他文件需要调用itemDataListSO的时候就需要先调用该命名空间using MFarm.Inventory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 添加一个命名空间，便于管理 namespace MFarm.Inventory { public class InventoryManager : Singleton\u0026lt;InventoryManager\u0026gt; { // 获得数据的控制权 public ItemDataList_SO itemDataListSo; } // 通过物品ID快速找到物品的details public ItemDetails GetItemDetails(int itemID) { return itemDataListSo.itemDetailsList.Find(i =\u0026gt; i.itemID == itemID); } } 每个场景的基础物体信息itemBase\n该ItemBase用于加载所有在该场景中生成的物体（果实，种子，伐木产生的内容等），每当需要生产内容的\n，就会去InventoryManager中找到对应的物品，然后每个物体需要有自己的sprite子物体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 namespace MFarm.Inventory { public class Item : MonoBehaviour { public int itemID; private ItemDetails _itemDetails; private SpriteRenderer _spriteRenderer; private BoxCollider2D _boxCollider2D; private void Awake() { _spriteRenderer = GetComponentInChildren\u0026lt;SpriteRenderer\u0026gt;(); _boxCollider2D = GetComponent\u0026lt;BoxCollider2D\u0026gt;(); } private void Start() { if (itemID != 0) InitItem(itemID); } private void InitItem(int ID) { itemID = ID; _itemDetails = InventoryManager.Instance.GetItemDetails(itemID); Sprite itemSprite; if (_itemDetails != null) { itemSprite = _itemDetails.itemOnWorldSprite != null ? _itemDetails.itemOnWorldSprite : _itemDetails.itemIcon; _spriteRenderer.sprite = itemSprite; // 修改boxCollider的大小以匹配实际的图片尺寸 Vector2 newSize = new Vector2(itemSprite.bounds.size.x, itemSprite.bounds.size.y); _boxCollider2D.size = newSize; // 修改offset以匹配在底部的锚点 _boxCollider2D.offset = new Vector2(0, itemSprite.bounds.center.y); } } } } 人物的拾取逻辑 为player添加一个脚本，该脚本用于当触发器触发的时候获得item对应的内容，并将地图上的item删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 namespace MFarm.Inventory { public class ItemPickUp : MonoBehaviour { private void OnTriggerEnter2D(Collider2D other) { Item item = other.GetComponent\u0026lt;Item\u0026gt;(); if (item != null) if (item.itemDetails.canPickedUp \u0026amp;\u0026amp; Input.GetKeyDown(KeyCode.E)) { // 拾取到背包 InventoryManager.Instance.AddItem(item, true); } } private void OnTriggerStay2D(Collider2D other) { Item item = other.GetComponent\u0026lt;Item\u0026gt;(); if (item != null) // OnTrigger和input,GetKeyDown的速率不匹配，一般来说是OnTrigger更新标志量，在update中触发按键 if (item.itemDetails.canPickedUp \u0026amp;\u0026amp; Input.GetKeyDown(KeyCode.E)) { // 拾取到背包 InventoryManager.Instance.AddItem(item, true); } } private void OnTriggerExit2D(Collider2D other) { } } } 1 // OnTrigger和input,GetKeyDown的速率不匹配，一般来说是OnTrigger更新标志量，在update中触发按键 背包数据结构 为背包和背包内容数据单独记录一个数据类型，背包的内容数据只需要保存数据的ID和数量放在dataCollection中，构建一个新的struct ——InventoryItem\n一般来说结构体类型都是值类型，每次生成对应内容时候都会为 成员变量赋值，因此不会出现当结构体或成员变量为空的情况。\n在本例子中，为避免背包的数据为空引起的错误，因此我们将背包的每个数据都定义为一个struct\n然后在为了适应多种存储物体的内容(背包，箱子，商店)，我们需要新建一个新的SO——InventoryBag_SO文件，用于存储一段InventoryItem，这样我们只需要创建不同的so，就可以找出得到不同的存储的数据\n1 2 3 4 5 [CreateAssetMenu(fileName = \u0026#34;InventoryBag_SO\u0026#34;, menuName = \u0026#34;Inventory/InventoryBag\u0026#34;)] public class InventoryBag_SO : ScriptableObject { public List\u0026lt;InventoryItem\u0026gt; inventoryItemList; } 背包检查 需求\n检查背包是否为空(通过检查在List中的每个item的数量是否为0) 检查背包是否已经有该物品（检查每个item的id是否为想要的ID） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private bool AddItemInIndex(int itemID, int itemIndex, int amount) { if (itemIndex == -1) // 如果背包没有当前物品 { var newItem = new InventoryItem{itemID = itemID, itemAmount = amount}; int vacancy = CheckBagCapacity(); if (vacancy != -1) { playerBag.inventoryItemList[vacancy] = newItem; itemIndex = vacancy; } } else // 如果有当前物品 { var newAmount = playerBag.inventoryItemList[itemIndex].itemAmount + amount; var newItem = new InventoryItem() { itemID = itemID, itemAmount = newAmount }; playerBag.inventoryItemList[itemIndex] = newItem; } // 返回是否已经将物体存放进入背包 return itemIndex != -1; } 注意结构体的赋值不能直接赋值，需要通过重新初始化才行\n绘制UI 用一个独立的场景来绘制UI 建立一个新的场景，在新场景中新增一个Canvas用于存放UI面板，然后将该画布的Canvas Scaler改为适配屏幕大小\n建议一组父物体 ，这组父物体用于作为真实UI工具的父物体，然后UI本身的内容需要在该物体下的子物体中进行实现。比如我们要完成一个快捷栏，则需要构建一个空物体Inventory然后再该物体下方构造UI组件Panel，将其作为快捷栏的具体组件。\n同时将该Action Bar的图片设置为我们需要的ui的框架图片，并将image Type修改Slice\n设置快捷按钮 为了保证每个快捷栏的内容都是可以点击的，我们将每个快捷栏设置为一个button，每个button有自己的图片和内容，然后再在按钮中设置一个图片，用于显示具体的物品信息，一个Image用于显示被选中时的高亮狂。\n分组 在action Bar中添加组件Horizontal Layout Group组件，用于为所有UI内容分组，然后将对其方式设置为middle center，这样就可以对内部的所有内容按照分组管理，如果其中的部分组件希望受到管理，但是有个性化的设置，则需要为单独的组件添加Layout Element组件\n绘制人物背包内UI 制作思路与普通的绘制UI相同\n添加一个背包的panel -\u0026gt; 背包具体的内容有新的panel存放-\u0026gt; 每个物体都是一个单独的button -\u0026gt; 设置不同的image来显示不同的内容。\nUI相关代码 获取SlotUI相关的信息（文字，数量，图片等） 在awake中获取组件也可能会导致update实时获取报错，因此为了效率，直接从Inspector组建中获得相关信息是最快的，因此对于一个private变量，通过[SerializeField]声明可以像public一样直接从Inspector获取内容\n隐藏声明[HideInInspector] 显示声明[SerializeField] 1 2 3 4 5 [Header(\u0026#34;组件获取\u0026#34;)] [SerializeField] private Image slotImg; [SerializeField] private TextMeshProUGUI amountText; [SerializeField] private Image slotHighLight; [SerializeField] private Button btn; 通过这样的方式就可以保证其他类无法获取组件，但是可以在inspector中获取组件\n对每个slot的内容进行更新，保证每个slot能获得对应的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private void Start() { Debug.Log(slotItemDetails); isSelected = false; // 如果itemDetails声明为public则会被系统默认初始化 if (slotItemDetails.itemID == 0) { UpdateEmptySlot(); } } /// \u0026lt;summary\u0026gt; /// 更新格子UI和信息 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;itemDetails\u0026#34;\u0026gt;获得的物品\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;amount\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void UpdateSlot(ItemDetails itemDetails, int amount) { slotItemDetails = itemDetails; slotImg.sprite = slotItemDetails.itemIcon; itemAmount = amount; amountText.text = itemAmount.ToString(); btn.interactable = true; slotImg.enabled = true; } /// \u0026lt;summary\u0026gt; /// 如果当前格子的内容为空了（丢弃或卖出），则清空相关内容 /// \u0026lt;/summary\u0026gt; public void UpdateEmptySlot() { if (isSelected) isSelected = false; slotImg.enabled = false; amountText.text = string.Empty; btn.interactable = false; } 控制背包UI的显示 使用一个新的脚本InventoryUI来控制整个界面中的所有背包格子（当拾取物品时，能直接对背包格子进行处理的代码）\n因此需要先创建一个管理每个格子信息的数组 ，\n1 2 3 4 public class InventoryUI : MonoBehaviour { [SerializeField] private SlotUI[] playerSlots; // 控制角色所有能控制所有格子（背包和快捷栏） } 同时将GameData中管理玩家背包的SO与这些数据进行绑定(因此需要为SlotUI.cs增加slotIndex，用于绑定数据)在slotUI.CS中添加public int slotIndex;然后具体的绑定函数，在inventoryUI.cs中填写\n1 2 3 4 5 6 7 8 private void Start() { // 在游戏运行的开始，将所有的数据进行绑定 for (int i = 0; i \u0026lt; playerSlots.Length; i++) { playerSlots[i].slotIndex = i; } } 由于更新UI的功能太过频繁使用，如果直接使用单例模式会导致耦合度太高，因此通过使用事件中心的模式，将所有需要更新UI的位置都注册该事件，每次更新都执行该事件\n创建一个静态类，该类用于控制所有事件，包括事件本身的声明，和其调用 1 2 3 4 5 6 7 8 9 10 11 12 13 // 该类是一个控制所有事件的静态类 public static class EventHandler { // 我要知道每次需要更新UI的slot是哪里（玩家的背包？还是玩家的储物箱） public static event Action\u0026lt;InventoryLocation, List\u0026lt;InventoryItem\u0026gt;\u0026gt; UpdateInventoryUI; // 执行对应的更新函数 public static void CallUpdateInventoryUI(InventoryLocation location, List\u0026lt;InventoryItem\u0026gt; items) { UpdateInventoryUI?.Invoke(location, items); } } 在InventoryUI.cs注册更新UI的事件(onEnable)，并对事件函数进行具体的定义（描述） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void OnUpdateInventoryUI(InventoryLocation location, List\u0026lt;InventoryItem\u0026gt; items) { switch (location) { case InventoryLocation.Player: for (int i = 0; i \u0026lt; playerSlots.Length; i++) { if (items[i].itemAmount \u0026gt; 0) { // 获得需要更新的物体的具体信息 var itemDetails = InventoryManager.Instance.GetItemDetails(items[i].itemID); playerSlots[i].UpdateSlot(itemDetails, items[i].itemAmount); } else { playerSlots[i].UpdateEmptySlot(); } } break; } } 在InventoryManager.cs的添加物品功能中调用静态类的事件调用函数，并传入对应的参数，保证事件能正常触发 1 2 3 // 更新UI EventHandler.CallUpdateInventoryUI(InventoryLocation.Player, playerBag.inventoryItemList); 注意，由于在游戏一开始，玩家可能有具体的数据内容，因此需要在游戏的一开始就调用更新UI的事件，比如在inventoryManager中的start中进行能调用\n控制背包的打开和关闭 控制背包打开与关闭主要通过控制背包的UI的active内容，因此需要一个对应go变量和bool变量，每次打开和关闭都是直接对该布尔值取反。\n1 2 3 4 5 public void OpenBagUI() { bagOpened = !bagOpened; bagUI.SetActive(bagOpened); } 由于需要设置按键打开，因此需要设置为在update方法中检测按键 如果需要设置对应的button，则需要为其设置onclicked函数， 为其添加一个Onclick事件，其需要先选择执行的GO，然后选择该GO下对应的脚本\n背包物品控制 设置点按格子高亮显示和动画 因此该代码需要在slotUI.cs中进行设置，由于Unity自带一个点击事件函数接口，因此可以直接调用该接口，用于知道当前内容是否已经被点击，或者点击了多少次：接口名：IPointerClickHandler，该函数内部有多种点击事件（单机，双击等）,需要实现其内部的点击函数public void OnPointerClick(PointerEventData eventData)\n1 2 3 4 5 6 public void OnPointerClick(PointerEventData eventData) { if (itemAmount == 0) return; isSelected = !isSelected; slotHighLight.gameObject.SetActive(isSelected); // } 由于点击了以后，isSelected不会再变化，因此当点击多个按钮会有多个highlight标签，需要设置当点击其中一个的时候，从父级物体中关闭其他格子的isSelected。\n因此我们在父物体的函数中设置slotHighlight的active，在inventoryUI.cs设置对应的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public void UpdateSlotHighlight(int index) { foreach (var slotUI in playerSlots) { if (slotUI.isSelected \u0026amp;\u0026amp; index == slotUI.slotIndex) { slotUI.slotHighLight.gameObject.SetActive(true); } else { slotUI.isSelected = false; slotUI.slotHighLight.gameObject.SetActive(false); } } } 在设置好该函数以后，在slotUI.cs中直接调用该函数即可\n1 2 3 4 5 6 public void OnPointerClick(PointerEventData eventData) { if (itemAmount == 0) return; isSelected = !isSelected; _inventoryUI.UpdateSlotHighlight(slotIndex); } 注意_inventoryUI是通过直接获取属性的方式得到的private InventoryUI _inventoryUI =\u0026gt; GetComponentInParent\u0026lt;InventoryUI\u0026gt;();\n设置格子高亮是个动画 先创建动画的animator，然后为该slot的预制体设置一个动画控制器，在该动画控制器中创建一个animation，将预先定好的animation放入即可。\n实现物体拖拽功能 实现拖拽功能的主要方式是通过调用三个Unity自带的接口IBeginDragHandle、IDragHandle、IEndDragHandler。分别用于处理拖拽开始，拖拽中和拖拽结束的时候情况。\n而具体的拖拽过程将通过新定义一个拖拽图层，并在该图层上增加一个被拖拽的物品图片，当拖拽时生成该图片，并在拖拽过程中跟随鼠标的射线，在拖拽结束时根据拖拽事件的结束位置实现相应功能。\n实现接口（在slotUI.cs中)\n定义Drag图层\n注意该图层需要设置与其他图层的关联为空，即不继承自主canvas，同时需要规定其排序结果，保证其内部的图片始终在原本的canvas上方\n同时需要设置图片的Raycast Target 为空，即该图片不能被识别为光线检测的的目标，其目的是为了解决两个都可以被光线检测的图层发生重叠的时候，会导致鼠标识别不到后方的图片。\n当Raycast Target为false，那么鼠标的射线会直接穿透该物体，从而到达后方。\n在InventoryUI.cs中获得拖拽图片，并在slotUI.cs的Drag方法中实现对图片的操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public void OnBeginDrag(PointerEventData eventData) { if (itemAmount != 0) { // 初始设置，显示被拖拽的物品 isSelected = !isSelected; inventoryUI.UpdateSlotHighlight(slotIndex); // 生成被拖拽的物品图片 inventoryUI.dragImg.sprite = slotImg.sprite; inventoryUI.dragImg.SetNativeSize(); // 保证图片不失真 inventoryUI.dragImg.enabled = true; } } public void OnDrag(PointerEventData eventData) { // 被生成的图片始终跟随鼠标移动 inventoryUI.dragImg.transform.position = Input.mousePosition; } public void OnEndDrag(PointerEventData eventData) { // 当结束事件时，检测当前是否碰撞到我们需要的slotUI内容 inventoryUI.dragImg.enabled = false; Debug.Log(eventData.pointerCurrentRaycast); } 其中eventData.pointerCurrentRaycast用于显示我释放鼠标时，碰撞的物体\n此处碰撞物体会与TMP的内容相碰撞，因此需要将所有TMP和图标都设置为无法被光线检测，因此需要修改预制体\n注意tmp的raycast target在 extra Setting中，并且要点击扩展折叠打开\n实现物体拖拽后位置交换与丢到地面 由于每个slot都有对应的序号，因此我们可以通过交换后，修改playerBag(dataSo)里对应需要对应的物品就行。\n实现物体拖拽后位置交换\n由于定义了拖拽结束函数，因此需要在该函数中判断拖拽的目标是某个UI还是地面（null） 然后将交换分为三类，分别是玩家背包之间的交换，玩家与仓库交换，玩家与商店交换 最后由于一定要操作背包的数据，因此在inventoryManager.cs定义交换函数，并将数据进行交换后使用更新UI事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // slotUI.cs // 当结束事件时，检测当前是否碰撞到我们需要的slotUI内容 inventoryUI.dragImg.enabled = false; // 获取交换目标 var target = eventData.pointerCurrentRaycast.gameObject; // 判断目标是地面还是某个UI（玩家背包，或者仓库，或者商店 if (target != null){ // 分为玩家背包之间的交换，玩家与仓库交换，玩家与商店交换 if (slotType == SlotType.Bag \u0026amp;\u0026amp; targetSlot.slotType == SlotType.Bag) { InventoryManager.Instance.SwapPlayerBagItem(slotIndex, targetSlot.slotIndex); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // inventoryManager.cs public void SwapPlayerBagItem(int currentIndex, int targetIndex) { var currentItem = playerBag.inventoryItemList[currentIndex]; var targetItem = playerBag.inventoryItemList[targetIndex]; // 判断目标位置是否有内容 if (targetItem.itemAmount == 0) { playerBag.inventoryItemList[targetIndex] = currentItem; playerBag.inventoryItemList[currentIndex] = new InventoryItem(); // 在C#中结构体内部的数值直接会被初始化为0 } else { playerBag.inventoryItemList[targetIndex] = currentItem; playerBag.inventoryItemList[currentIndex] = targetItem; } // 更新UI内容 EventHandler.CallUpdateInventoryUI(InventoryLocation.Player, playerBag.inventoryItemList); } 将物品拖拽到地面\n将物体拖 景也可生成的，因此需要一个专门的Manager来管理这些在地面上生成的物体。\n首先需要将屏幕坐标转化为世界坐标Camera.main.ScreenToWorldPoint(Vector3) 定义一个事件，专门用于通知itemManager需要在当前位置生成一个物体 使用ItemManager来管理地面上的物体，因此itemManger用于声明事件的执行过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // slotUI.cs else // 如果是地面 { if (slotItemDetails.canDropped) { // 在2d游戏中z轴默认是-10，而将转化为世界坐标需要将其取消掉 var dropPos = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, -Camera.main.transform.position.z)); // 生成item EventHandler.CallInstantiateItemInScene(slotItemDetails.itemID, dropPos); } } 1 2 3 4 5 6 // EventHandler.cs public static event Action\u0026lt;int, Vector3\u0026gt; InstantiateItemInScene; public static void CallInstantiateItemInScene(int ID, Vector3 pos) { InstantiateItemInScene?.Invoke(ID, pos); } 该manager用于注册和声明预制体的生成的方法，而具体的激活预制体生成，则通过调用action事件来使用。也就是说manager只是用于提供预制体生成的函数，并保证该函数能被事件中心获取，而预制体的生成将用逻辑函数在具体的功能中激发事件中心来实现。\n其中itemParent用于保证生成的item在Unity的层次窗口中不会过于混乱，生成的所有item都会以itemParent为父物体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // itemManager.cs public class ItemManager : MonoBehaviour { public Item itemPrefab; private GameObject _itemParent; private void Start() { _itemParent = GameObject.FindGameObjectWithTag(\u0026#34;ItemParent\u0026#34;); } private void OnEnable() { EventHandler.InstantiateItemInScene += OnInstantiateItemInScene; } private void OnDisable() { EventHandler.InstantiateItemInScene -= OnInstantiateItemInScene; } /// \u0026lt;summary\u0026gt; /// 在当前场景中生成目标item /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;ID\u0026#34;\u0026gt;item的ID\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;pos\u0026#34;\u0026gt;item的对应位置\u0026lt;/param\u0026gt; private void OnInstantiateItemInScene(int ID, Vector3 pos) { var item = Instantiate(itemPrefab, pos, Quaternion.identity, _itemParent.transform); item.itemID = ID; } } 给物品增加浮窗ItemTooltip UI 制作一个单独的ItemToolTip窗口，窗口背景图片是一个Image，然后再内部添加内容\n由于内容涉及到多行，因此为该主体parent添加组件Vertical Layout Group用于控制每个子物体的宽度和长度\n注意：只要内部有子物体，且每个子物体的大小都需要被控制的话，就需要添加该组件\n同时也为了保证窗口能一直保持合适的大小，需要添加组件Content Size Filter，对垂直或水平方向设置自动拓展。\n然后使用Layout Element组件可以指定最小的宽度和高度\n如果要保证孩子宽度一定，但是高度自由控制，则需要如下方式处理\n代码 该部分代码的实现思路是：\n为Item Tooltip直接挂载对应的脚本ItemTooltip.cs， 并使用脚本获得该GO下的所有部分的控制权 设置一个方法，该方法需要获得物品信息，将Item ToolTip与当前的数据进行绑定，并进行显示。 由于InventoryUI是用于显示所有背包栏等数据的显示的管理页面，因此此处需要设置Item Tooltip的变量，并将我们设置号的GO挂载到该变量上 为了将SlotUI和我们显示Item Tooltip信息相分割，因此需要设置不同的脚本 在新的脚本showItemDetails中获取InventoryUI中挂载的Item Tooltip的变量，当鼠标移动到SlotUI上时，从InventoryUI的Item Tooltip的变量启动我们的设置函数，然后显示对应的窗体 修改窗体显示方式，设置快速渲染，保证每次窗体的显示不会有延迟 具体实现：\n实现itemTooltipGO的数据控制，以及编写绑定函数 同时为了保证不会延迟渲染，因此要通过代码实现更新details后就直接渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class ItemTooltip : MonoBehaviour { /* 获取ItemTooltip GO的所有内容的控制权 */ [SerializeField] private TextMeshProUGUI nameText; [SerializeField] private TextMeshProUGUI typeText; [SerializeField] private TextMeshProUGUI descriptionText; [SerializeField] private Text priceText; [SerializeField] private GameObject bottomPart; /// \u0026lt;summary\u0026gt; /// 为itemTooltip窗体设置需要显示的内容 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;details\u0026#34;\u0026gt;具体信息\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;itemType\u0026#34;\u0026gt;鼠标当前选取的窗体的类别（区别商店和玩家背包）\u0026lt;/param\u0026gt; public void SetupTooltips(ItemDetails details, SlotType slotType) { nameText.text = details.itemName; typeText.text = getItemType(details.itemType); descriptionText.text = details.itemInfo; if (details.itemType == ItemType.Seed || details.itemType == ItemType.Commodity || details.itemType == ItemType.Furniture) { bottomPart.SetActive(true); int showPrice = details.itemPrice; if (slotType == SlotType.Bag || slotType == SlotType.Box) { showPrice = (int)(showPrice * details.sellPercentage); } priceText.text = showPrice.ToString(); } else { bottomPart.SetActive(false); } LayoutRebuilder.ForceRebuildLayoutImmediate(GetComponent\u0026lt;RectTransform\u0026gt;()); } /// \u0026lt;summary\u0026gt; /// 转化类型名称 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;detailsItemType\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private string getItemType(ItemType detailsItemType) { // 语法糖 return detailsItemType switch { ItemType.Seed =\u0026gt; \u0026#34;种子\u0026#34;, ItemType.Commodity =\u0026gt; \u0026#34;商品\u0026#34;, ItemType.Furniture =\u0026gt; \u0026#34;家具\u0026#34;, ItemType.BreakTool =\u0026gt; \u0026#34;工具\u0026#34;, ItemType.CollectTool =\u0026gt; \u0026#34;工具\u0026#34;, ItemType.ChopTool =\u0026gt; \u0026#34;工具\u0026#34;, ItemType.HoeTool =\u0026gt; \u0026#34;工具\u0026#34;, ItemType.ReapTool =\u0026gt; \u0026#34;工具\u0026#34;, ItemType.WaterTool =\u0026gt; \u0026#34;工具\u0026#34;, _ =\u0026gt; \u0026#34;其他\u0026#34; }; } 编写具体实现浮窗的函数 由于一定需要SlotUI对应的按钮上因此需要[RequireComponent(typeof(SlotUI))]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [RequireComponent(typeof(SlotUI))] public class ShowItemDetails : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler { private SlotUI _slotUI; private InventoryUI InventoryUI =\u0026gt; GetComponentInParent\u0026lt;InventoryUI\u0026gt;(); private void Awake() { _slotUI = GetComponent\u0026lt;SlotUI\u0026gt;(); } public void OnPointerEnter(PointerEventData eventData) { if (_slotUI.itemAmount != 0) { InventoryUI.itemTooltip.gameObject.SetActive(true); InventoryUI.itemTooltip.SetupTooltips(_slotUI.slotItemDetails, _slotUI.slotType); } else { InventoryUI.itemTooltip.gameObject.SetActive(false); } } public void OnPointerExit(PointerEventData eventData) { InventoryUI.itemTooltip.gameObject.SetActive(false); } } 界面优化 设置最小尺寸的组件Layout Element\n","date":"2023-03-05T19:16:30+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E4%B8%89/","title":"麦田物语开发日记(三)"},{"content":"场景设置 设置边界 在cinemachine中设定Confiner（不用刻意选择confiner)，然后选择摄像机的碰撞范围\n由于边界需要是一个GO，因此我们需要设置一个独立的GO，然后为其设置碰撞体，由于地图大小不一定相同，因此采用polygon Collder2d完成\n由于每个场景都是独立的，而Bound在不同的地图之中，因此该GO不能直接赋值给CineMachine\n，需要通过代码去获得该Bound然后赋值给CineMachine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 挂载到CineMachine中 public class SwitchBounds : MonoBehaviour { private void Start() { //todo 在切换场景时修改 SwitchConfinerShape(); } // 在切换场景之后修改边界 private void SwitchConfinerShape() { PolygonCollider2D confinerShape = GameObject.FindGameObjectWithTag(\u0026#34;BoundsConfiner\u0026#34;) .GetComponent\u0026lt;PolygonCollider2D\u0026gt;(); CinemachineConfiner cinemachineConfiner = GetComponent\u0026lt;CinemachineConfiner\u0026gt;(); cinemachineConfiner.m_BoundingShape2D = confinerShape; cinemachineConfiner.InvalidatePathCache(); // 清除切换边界的缓存（runtime） } } 注意需要将该碰撞器设置为isTriger否则会与人物将碰撞\n设置树木遮挡渐变 为树木设置碰撞体，如果发生碰撞，就将数的sprite的透明度调低\n设置一个通用的脚本来管理所有需要被透明化的物体\n基础的透明化执行逻辑通常是通过携程，去不断缩小sprite的透明度，但是当item过多的时候，会导致携程开的过多，因此为了让代码更加简单，因此采用一个工具Dotween。该插件可以帮助我们很好的管理所有界面效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* 由于需要对物体的sprite的透明度进行修改，因此必须有sprite Renderer*/ [RequireComponent(typeof(SpriteRenderer))] public class ItemFader : MonoBehaviour { private SpriteRenderer _spriteRenderer; private void Awake() { _spriteRenderer = GetComponent\u0026lt;SpriteRenderer\u0026gt;(); } /* 设置两个函数，当player和当前物体碰撞的时候，调用该函数*/ /// \u0026lt;summary\u0026gt; /// 逐渐恢复颜色 /// \u0026lt;/summary\u0026gt; public void FadeIn() { Color targetColor = new Color(1, 1, 1, 1); // 使用dotween修改物体的颜色 _spriteRenderer.DOColor(targetColor, Settings.FadeDuration); } /// \u0026lt;summary\u0026gt; /// 颜色逐渐变淡 /// \u0026lt;/summary\u0026gt; public void FadeOut() { Color targetColor = new Color(1, 1, 1, Settings.TargetAlpha); // 使用dotween修改物体的颜色 _spriteRenderer.DOColor(targetColor, Settings.FadeDuration); } } 然后在人物身上挂载新的脚本，当发生碰撞的是将被碰撞物挂在itemFader的子物体进行淡入淡出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /*** * 当与场景物体重叠时，将场景物体半透明化 */ public class TriggerItemFader : MonoBehaviour { /// \u0026lt;summary\u0026gt; /// 发生碰撞时，如果被碰撞的物体可以淡化，则对其子物体进行淡化处理 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;碰撞物体\u0026lt;/param\u0026gt; private void OnTriggerEnter2D(Collider2D other) { // 获得当前碰撞物体的ItemFader ItemFader[] faders = other.GetComponentsInChildren\u0026lt;ItemFader\u0026gt;(); if (faders.Length \u0026gt; 0) { foreach (var fader in faders) { fader.FadeOut(); } } } /// \u0026lt;summary\u0026gt; /// 不再发生碰撞时，则恢复淡化效果 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;碰撞物体\u0026lt;/param\u0026gt; private void OnTriggerExit2D(Collider2D other) { ItemFader[] faders = other.GetComponentsInChildren\u0026lt;ItemFader\u0026gt;(); if (faders.Length \u0026gt; 0) { foreach (var fader in faders) { fader.FadeIn(); } } } } 注意：由于我们设置的是寻找某一个父物体发生碰撞，然后子物体的sprite变色，因此对于单个图层的物体需要为其创建一个父物体\n","date":"2023-03-05T19:16:29+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E4%BA%8C/","title":"麦田物语开发日记(二)"},{"content":"素材整理 将图片设置设置为预设值 将一个图片设置好需要的样式后，点击\n将该样式进行保存，然后可以应用于其他图片\n导入人物素材 为了保证角色的图层属于同一个类别，因此我们需要在一个父物体中设置Sort Group用于归类所有的需要渲染的图层。\n由于是2D游戏有图层之间的关系，因此需要设置一个单独的渲染图层，在edit layer中新增一个新的sort layer，将sort Layer设置为Instance表示所有和人物有关的渲染都用该图层，并将所有的内容实例相关的sort layer都设置该图层\n注意需要将所有的内容的渲染的参考点Sprite Sort Point设置为Pivot，这样才能保证覆盖的正确性。\n设置图层覆盖条件\n在Unity中默认以Z轴为渲染覆盖的判定，由于在2D俯视角游戏中没有z轴的概念，因此采用y轴作为判断覆盖的条件（即某个GO的y轴大于另一个GO的y轴的位置，即可以实现图层的覆盖）\n因此需要在edit -\u0026gt; project setting-\u0026gt; graphics-\u0026gt;transparency Sort Axis中将x和z设置为0，y设置为1，同时向mode设置为CustomAxis 即可实现。\n实现人物的移动 为人物添加碰撞体和刚体（注意俯视角的游戏 重力一定要设置为0）\n人物的移动方向可以通过input.getAxis的方式获得，而具体的方向需要通过x轴和y轴进行组合。\n1 2 3 4 5 6 7 8 9 10 11 12 private void PlayerInput(){ _inputX = Input.GetAxis(\u0026#34;Horizontal\u0026#34;); _inputY = Input.GetAxis(\u0026#34;Vertical\u0026#34;); // 添加移动方向 // 限制按下两个方向键的时候的移动速度（防止斜方向的速度快于单一方向移动速度） if (_inputY != 0 \u0026amp;\u0026amp; _inputX != 0){ _inputX = _speedLimit * _inputX; _inputY = _speedLimit * _inputY; } _movementInput = new Vector2(_inputX, _inputY); } 具体的移动方式在2D横板游戏中是给rigid body添加一个力，但在俯视角的游戏中通常是获得当前坐标，加上方向坐标 * 移动速度\n1 2 3 4 private void Movement(){ // 乘以deltaTime是为了修正在不同设备上的差距 _rb.MovePosition(_rb.position + _movementInput * speed * Time.deltaTime); } 两个方法的调用\n1 2 3 4 5 6 7 private void Update(){ PlayerInput(); } // 由于FixedUptda是固定时间更新一次，因此不同帧数也会有相同的内容 private void FixedUpdate(){ Movement(); } 绘制地图 首先为需要执行的内容绘制对应的图层，比如多层的地面，水沟，土地等 sorting layer用于处理所有渲染的顺序关系，其中越靠后的物体优先级越高，越后渲染（在2D图层中，也就会在低优先级图层的上方）\nlayers用于处理所有和碰撞和相机射线（是否被相机所显示，以及遮挡剔除效果）有关的内容\n通过设置一个不变的场景来避免每次切换场景都重新生成数据 新建一个场景，然后将场景直接拖入主场景的hierachy面板中，并删除其camera，然后将对应的地图结构存储进入新的场景\n这样我们就能始终用不变的人物信息和摄像头来控制场景\n此时可以将该场景作为一个模板数据，这样就可以创建多个不同的地图，完成不同场景的切换效果。\n为tile maps设置调色盘 点击tile map后，选择\n创建一个新的调色盘，然后将所有被切割好的素材拖拽进入调色盘中，就可以通过调色盘对地图进行绘制了，注意需要选中对应的Tile Map，该tile map需要先设置好对应的sorting layer\n有规律地绘制地图 创建绘制规则地图的2D-\u0026gt;Tile -\u0026gt; Rule Tile 然后设置具体的绘制规则\n消除2D游戏的瓦片缝隙 设置一个Sprite Atlas用于将整个地图打包为一个图片2D - Sprite Atlas, 然后将所有需要使用的素材都放入该Atlas中，并设置对应的压缩方式\n设置相机 创建Cinemachine，跟随玩家，然后再主相机中添加``设置适合于当前项目的内容\n然后在CM中添加对应的Pixel Perfect Camera,\n并且为CM设置合适的Dead Zoom等内容\n为瓦片地图添加碰撞 为设置的瓦片地图的Collision层添加碰撞组件Tilemap Collider 2D\n同时为了保证我们添加的碰撞是一个整体，而不是独立的瓦片，因此需要添加组件Composite Collider 2D(此时会自动添加rigid body组件)\n将rigid body的类型改为静态，并将tilemap collider 2D修改为Used by composite，并将瓦片渲染关闭\n此时即可添加对应碰撞图层，且不会显示该图层。\n设置树的预制体 在生成树的预制体，首先需要自定义一颗树，为了定义树的动画，需要将树分为树冠和树桩，此时树的父物体并不能设置sorting group，否则会导致渲染的锚点改变，而出现渲染错误。\n然后单独为树冠设置动画即可。\n动画则是将所有动画帧都放在动画序列上，在不同的时刻播放不同的树冠的图片即可\n","date":"2023-03-05T19:16:27+08:00","image":"https://ruizumoe.github.io/img/story_of_wheat_field/wheatField.jpg","permalink":"https://ruizumoe.github.io/p/%E9%BA%A6%E7%94%B0%E7%89%A9%E8%AF%AD%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%E4%B8%80/","title":"麦田物语开发日记(一)"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://ruizumoe.github.io/p/markdown-syntax-guide/img/img2_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://ruizumoe.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nGist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://ruizumoe.github.io/p/rich-content/","title":"Rich Content"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://ruizumoe.github.io/p/math-typesetting/","title":"Math Typesetting"}]